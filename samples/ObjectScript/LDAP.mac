ROUTINE LDAP
#;This is from https://github.com/intersystems/Samples-Security
#;Use or operation of this code is subject to acceptance of the license available in the code
#;repository for this code.
#;/*=======================Maintenance========================*/
#;STC2262 12/12/13 Steve Clay, LDAP Group authorization implementation
#;STC2190 03/10/13 Support LDAP paged results on Windows platforms for any LDAP server
#;AD004   03/02/11 Update LDAP examples to uses schema attribute names
#;STC1760 02/18/10 Update LDAP class documentation and samples
#;STC1585 04/28/09 Update documentation and better error messages
#;STC1573 04/13/09 Update documentation
#;STC1525 01/12/09 Update LDAP examples and documentation
#;/*====================End Maintenance======================*/
#include %syLDAP
#include %syLDAPFunc
#include %sySite
#;There are several samples included in this routine to manipulate or search
#;an LDAP server. For more information of the class methods, see the class
#;documentation in the %SYS.LDAP class.
#;
#;Since LDAP server's schemas can vary widely from customer to customer, parts of each example
#;will need to be slightly modified to make it work in the different environments it can operate in.
#;Parts of the routine which may need to be modified will be marked with:
#;
#;"***Modify the following line(s)***"
#;
#;Here are a few defines which are common to all the examples, which you will want to
#;modify for your environment.
#;
#;Define the LDAPServer you wish to connect to.
#;The LDAPServer name should be the fully qualified name including the fully
#;qualified domain name (FQDN).
#;For eample, if your machine is called "testldap", you would want to append the domain
#;to this and use "testldap.internal.com" in your Init() method call. This is especially
#;important when using certificates to run ldap across an encrypted channel.
#;This connection is made on port 389.
#;By default, port 389 is an unsecure connection. Once the connection is made on 389,
#;we call the Start_TLS function to turn on SSL for that port, at which point the connection
#;becomes secure.
#;
#;If you are using a Windows machine, and connecting to a Windows AD LDAP server, you
#;can avoid using the start_ tls call by specifying port 636 in the Init() method. This
#;will immediately cause an SSL connection between the LDAP server and your machine.
#;Note that you must have the certificate already loaded before this call, and the Windows
#;AD LDAP server must be configured to run on port 636. If you are connecting to an openldap
#;server using SSL, from a windows client, then you must also use port 636 to form the connection.
#;StartTLS is not supported between windows clients and openldap servers.
#;
#;If you want to test your LDAP functionality outside of your production environment,
#;you can run an LDAP server on a different port. One way to do this using a UNIX server
#;is to run the LDAP server on a different port (say 388) in debug mode in a terminal
#;as follows (make sure you have admin privileges on the unix machine):
#;
#; slapd -h ldap://:388 -d255
#;
#; To connect on the alternate port, specify the alternate port in the Init() method.
#;
#;"***Modify the following line***"
#define LDAPServer "testldap.internal.com"

#;If the LDAP server we are connecting to is a Windows Active Directory domain server, set
#;the value of this macro to 1. Set it to 0 if it is another type of server
#;"***Modify the following line***"
#define WindowsLDAPServer 1

#;If the Cache' Client machine which is trying to do the authentication is a
#;Windows machine, then set the value of this macro to 1. If the client is a Unix, VMS,
#;Linux or Mac set it to 0.
#;"***Modify the following line***"
#define WindowsCacheClient 1

#;If you wish to use a secure SSL connection, then set the value of this
#;macro to 1. Make sure you have a valid certificate file loaded to make this work.
#;When using/testing for the first time in your own environment, it is best to set this parameter
#;to 0 so that any connection issues can be differentiated from SSL/certificate issues.
#;For a windows client, the certificate file should be loaded into the windows
#;certificate registry. For a unix client, we need to specify where the file is.
#;Note that you should first run your test without a secure connection to verify that
#;it works before introducing the complexity of running a secure connection.
#;"***Modify the following 2 lines***"
#define UseSecureConnection 0
#define UnixCertificateFile "/home/user/certs/TestCACert.pem"

#;If you are connecting to a Unix ldap server (from either a windows or unix LDAP client),
#;you will need to modify the following lines. Make sure that DN (user) specified
#;has at least read privileges on the LDAP database (for EXAMPLE 1), or
#;Read/Write privilege (for EXAMPLE 3).
#;"***Modify the following 2 lines***"
#define UnixAdminDN				"uid=root,ou=people,dc=internal,dc=com"
#define UnixAdminPassword		"password"

#;If you are connecting to a windows ldap server from a unix client, you will need to
#;modify the following lines. Make sure that DN (user) specified has at least read
#;privileges on the LDAP database (for EXAMPLE2), or Read/Write privilege (for EXAMPLE3).
#;"***Modify the following 2 lines***"
#define WindowsAdminDN			"CN=administrator,OU=Users,DC=internal,DC=com"
#define WindowsAdminPassword	"password"

#;If you are connecting to a windows ldap server from a windows client, you will need to
#;modify the following lines. Make sure that Windows username specified has at least read
#;privileges on the LDAP database (for EXAMPLE2), or Read/Write privilege (for EXAMPLE3,
#;EXAMPLE4, and EXAMPLE6).
#;"***Modify the following 3 lines***"
#define WindowsAdminUser		"administrator"
#define WindowsAdminPassword	"password"
#define WindowsDomain			"internal.com"

#;We need to define the BaseDN of where we want to start searching for users in. This is
#;the root level of the LDAP tree where all the users defined in the LDAP database reside
#;under. For example, on a Unix LDAP server all the users may be defined under
#; ou=people,dc=internal,dc=com. On Windows, they might be "ou=Users,dc=internal,dc=com".
#; Some schemas may have their users in multiple trees, in which case you have to specify
#;the BaseDN at a higher level so all the branches can be searched, e.g. "dc=internal,dc=com".
#;"***Modify the following line***"
#define WindowsBaseDN "dc=internal,dc=com"
#define UnixBaseDN "ou=people,dc=internal,dc=com"

#;We now need to define the unique identifier attribute in the User record which uniquely
#;identifies the user. For Windows LDAP servers, you usually do not need to modify this
#define WindowsFilter "sAMAccountname"

#;LDAP schemas on Unix machines can vary widely. One of these two lines is what you
#;would most likely use for the filter. Note your schema may use cn or uid here.
#;"***Modify the following line***"
#define UnixFilter "uid"
#;define UnixFilter "cn"

#;Let's return these attributes from the user's LDAP record. Pick out some which
#;are common on windows or unix ldap servers. Add or delete the desired ones from the list.
#;"***Modify the following 2 line***"
#define WindowsAttributeList $lb("displayName","telephoneNumber")
#define UnixAttributeList	$lb("loginShell","homeDirectory")

#;EXAMPLE 7 uses a group as part of the filter, you can change
#;the group definition here
#;"***Modify the following line***"
#define GroupFilter "(memberOf=CN=CacheGroup,OU=Groups,DC=example,DC=com)"

#;----------------------------------------------------------------------------
#;EXAMPLE 1
#;Example to get a username and password, validate against an LDAP server, then
#;return some of the user's LDAP attributes using a secure SSL connection.
#;This routine will work against a Windows Active directory domain server,
#;or a Unix/OPENLDAP style LDAP server.
#;----------------------------------------------------------------------------
#;
EXAMPLE1() Public {
#;
#;Get a username and password to validate.
 w !,"Initializing LDAP connection to "_$$$LDAPServer,!
 Read !,"Username: ",Username
 u 0:(:"+S")
 Read !,"Password: ",Password
 u 0:(:"-S")
 w !
 s Status=$$EXAMPLE1Authenticate(Username,Password,.Attributes)
 i +Status'=0 {
	 w !,"Error "_Status
 } else {
	 w !,"User "_Username_" authenticated"
	 s Attribute=""
#;Now print out the returned attributes. Note that attributes are returned as a $list value,
#;and some attributes are "multi-value", meaning that they have several values for them.
	 f  {
		s Attribute=$o(Attributes(Attribute)) q:Attribute=""
	 	w !,Attribute_" = "_$ListToString(Attributes(Attribute))
	 }
	 w !
 }
 q
}
#;
#;This subroutine handles the actual authentication of the user.
#;Parameters:
#;Username - Username to authenticate
#;Password - Password to use for authentication
#;Attributes (byref) - Array of attributes to returned. Format is:
#; Attributes("AttributeName")=""
#;
#;Return values:
#; 0 - Success; Attributes and values are returned in the Attributes array
#; Format of the returned Attributes array is:
#; Attributes("AttributeName")=$lb(Value1,Value2,...,ValueN)
#; Error - LDAPErrornumber,LDAP Error message
EXAMPLE1Authenticate(Username,Password,Attributes) Private {
#;We need to trap all errors so we can close the LDAP channel, otherwise a memory
#;leak can occur.
 s $zt="Error"
#;No error initially
 s Status=0
 if $$$WindowsLDAPServer,$$$WindowsCacheClient {
#;The AdminUser and AdminPW need to be for an LDAP user who has privileges to
#;read the entire LDAP database on the Active Directory windows server. We only support
#;windows 2003 servers or above. Note we can use the actual username and
#;password here (along with the domain) since we are going from
#;windows->windows.
	s AdminUser=$$$WindowsAdminUser
	s AdminPW=$$$WindowsAdminPassword
	s Domain=$$$WindowsDomain
 } else {
#;The AdminDN and the AdminPW need to be for an LDAP user who has privileges to
#;read the entire LDAP database. We need the fully qualified distinguished name (DN) here to use in
#;the Simple_Bind command since we are not communicating between two windows machines.
	if $$$WindowsLDAPServer {
		s AdminDN=$$$WindowsAdminDN
		s AdminPW=$$$WindowsAdminPassword
	} else {
		s AdminDN=$$$UnixAdminDN
		s AdminPW=$$$UnixAdminPassword
	}
 }
#;The following line sets up the internal LDAP structures.
 i $$$ISWINDOWS,$$$UseSecureConnection {
	s LD=##Class(%SYS.LDAP).Init($$$LDAPServer,636)
 } else {
	s LD=##Class(%SYS.LDAP).Init($$$LDAPServer)
 }
 i LD=0 {
	s Status=##Class(%SYS.LDAP).GetLastError()
	g Done
 }
 i $$$UseSecureConnection {
 	i '$$$ISWINDOWS {
		s Status=##Class(%SYS.LDAP).SetOption(LD,$$$LDAPOPTXTLSCACERTFILE,$$$UnixCertificateFile)
   		i Status'=$$$LDAPSUCCESS {
    		s Status=Status_",ldap_setoption(Certificate) - "_##Class(%SYS.LDAP).Err2String(Status)
    		g Done
   		}
#;Turn on TLS. This forms the connection, and exchanges the certificate, and makes this a
#;secure connection.
#;Error -11 or -12 most likely means that the certificate has a problem, or possibly
#;the value for LDAPServer is not correct or the right format in the LDAP_Init call. If you have
#;problems getting this to work, you can run the server in debug mode as described above, and
#;watch the debug messages on the server as the certificates exchange between the machines.
		s Status=##Class(%SYS.LDAP).StartTLSs(LD)
		i Status'=$$$LDAPSUCCESS {
			s Status=Status_",ldap_setoption(Certificate) - "_##Class(%SYS.LDAP).Err2String(Status)
			g Done
 		}
	}
 }
#;At this point if we specified a secure connection, we have one. If we didn't, we are not actually
#;connected to the LDAP server yet, the connection will happen on the bind below.
 if $$$WindowsCacheClient,$$$WindowsLDAPServer {
#;Now we bind (authenticate) to the server using the Username/PW/domain
#;of the LDAP administrator who has read access to the entire LDAP database. We need
#;to do this first so we have privileges to search for the user we want to authenticate.
	s Status=##Class(%SYS.LDAP).Binds(LD,"",$lb(AdminUser,Domain,AdminPW),$$$LDAPAUTHNEGOTIATE)
	i Status'=$$$LDAPSUCCESS {
		s Status=Status_",ldap_Binds(AdminDN) - "_##Class(%SYS.LDAP).Err2String(Status)
		g Done
 	}
 } else {
#;Ok, now we bind (authenticate) to the server using the DN of the LDAP administrator who has
#;read access to the entire LDAP database. We need to do this first so we have
#;privileges to search for the user we want to authenticate.
	s Status=##Class(%SYS.LDAP).SimpleBinds(LD,AdminDN,AdminPW)
	i Status'=$$$LDAPSUCCESS {
		s Status=Status_",ldap_Simple_Bind(AdminDN) - "_##Class(%SYS.LDAP).Err2String(Status)
		g Done
 	}
 }
#;Now that we have read access to the LDAP server, we need to search the LDAP
#;database for the user we want to authenticate in order to get their DN.
#;Once we have their DN, we can then use LDAP_Simple_Bind (authenticate) them using
#;their password.
#;Set up the Filter to be the unique identify for the user in the LDAP database.
#;For an OPENLDAP server it is usually cn=Username. For a Windows AD server it is
#;almost always sAMAccountname=Username
 i $$$WindowsLDAPServer {
#;It is usually not necessary to modify the following line since most windows AD servers are set
#;up with this being the unique identifier for the user.
	s Filter=$$$WindowsFilter_"="_Username
 } else {
#;LDAP schemas on Unix machines can vary widely. This is what you would use for the filter
#;if you were using a default schema. Note your schema may use cn or uid here.
	s Filter=$$$UnixFilter_"="_Username
 }
 i $$$WindowsLDAPServer {
	s AttributeList=$$$WindowsAttributeList
 } else {
	s AttributeList=$$$UnixAttributeList
 }
 i $$$WindowsLDAPServer {
	s BaseDN=$$$WindowsBaseDN
 } else {
	s BaseDN=$$$UnixBaseDN
 }
#;$$$LDAPSCOPESUBTREE means to search the entire tree beneath the BaseDN used.
 s SearchScope=$$$LDAPSCOPESUBTREE
#;Max length of time the search can last.
 s Timeout=10
#;Return just the first thing we find.
 s SizeLimit=1
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,SearchScope,Filter,AttributeList,0,"","",Timeout,SizeLimit,.SearchResult)
 i Status'=$$$LDAPSUCCESS {
#;If we got a funny username entered by the user, we may have a bad filter. Note that on some LDAP
#;implementations, if you get an error here, you cannot recover. You must shut down the connection
#;(unbind), and call LDAP_Init/Bind again. If you don't, you may CORE at some later time.
	i Status=$$$XLDAPFILTERERROR {
		s Status="1,User "_Username_" does not exist"
	} else {
		s Status=Status_",ldap_Search_Ext - "_##Class(%SYS.LDAP).Err2String(Status)
	}
	g Done
 }
#;See how many entries were returned by the search.
 s NumEntries=##Class(%SYS.LDAP).CountEntries(LD,SearchResult)
 i NumEntries=-1 {
	 s Status=##Class(%SYS.LDAP).GetError(LD)
	 s Status=Status_",ldap_Count_Entries - "_##Class(%SYS.LDAP).Err2String(Status)
	 g Done
 }
#;If NumEntries=0, then either there is no LDAP user for the username
#;in the database, or the BaseDN parameter needs to be set higher in the tree.
 i NumEntries=0 {
	s Status="1,User "_Username_" does not exist"
 	g Done
 }
#;If the search returned too many items, then the Filter is probably wrong.
 i NumEntries>1 {
	s Status="1,LDAP Filter is not unique"
 	g Done
 }
#;Now get the pointer to the first (and only) entry in the returned search list.
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 {
	s Status=##Class(%SYS.LDAP).GetError(LD)
	s Status=Status_",ldap_FirstEntry - "_##Class(%SYS.LDAP).Err2String(Status)
	g Done
 }
#;Retrieve all the user's attributes we asked for. Note that we are still in the context of the
#;Admin user who has privileges to search the LDAP database.
 s Attribute=##Class(%SYS.LDAP).FirstAttribute(LD,CurrentEntry,.Ptr)
 while (Attribute'="") {
	s Values=##Class(%SYS.LDAP).GetValues(LD,CurrentEntry,Attribute)
	s ReturnAttributes(Attribute)=Values
	s Attribute=##Class(%SYS.LDAP).NextAttribute(LD,CurrentEntry,.Ptr)
 }
#;If we have a windows client, and a windows AD server, then we can simply execute a bind on the
#;using the passed in username, password, and domain. Otherwise we need to retrieve the DN
#;of the user, and bind using that. Note that once we execute the Bind, we have authenticated
#;the user, and only then should we return their attributes to the caller. As a side affect of
#;this bind, we will still be connected to the LDAP server, but will be operating in the context
#;of the user we just did the bind for, so we MAY NOT still have privileges to search the LDAP
#;database. If we want to search for more stuff, we have to go back and execute another bind
#;using the Admin credentials.
#;Make sure the password is not null. A null password will actually bind "anonymously"
#;and return success even though it does not match the user's password
 i Password="" {
	s Status="1,ldap_Simple_Bind("_UserDN_") - password cannot be null"
	g Done
 }
 if $$$WindowsCacheClient,$$$WindowsLDAPServer {
	s Status=##Class(%SYS.LDAP).Binds(LD,"",$lb(Username,Domain,Password),$$$LDAPAUTHNEGOTIATE)
	i Status'=$$$LDAPSUCCESS {
		s Status=Status_",ldap_Binds(AdminDN) - "_##Class(%SYS.LDAP).Err2String(Status)
		g Done
 	}
 } else {
#;Retrieve the DN for the user we found so we can bind on it.
	s UserDN=##Class(%SYS.LDAP).GetDN(LD,CurrentEntry)
#;Now authenticate the user based on their DN
	s Status=##Class(%SYS.LDAP).SimpleBinds(LD,UserDN,Password)
	i Status'=$$$LDAPSUCCESS {
		s Status=Status_",ldap_Simple_Bind("_UserDN_") - "_##Class(%SYS.LDAP).Err2String(Status)
		g Done
 	}
 }
#;Now that we have authenticated, return the attributes
 k Attributes m Attributes=ReturnAttributes
Done
#;We must free the search buffer here otherwise future LDAP calls may core
#;or memory leak.
 i $d(SearchResult) d ##Class(%SYS.LDAP).MsgFree(SearchResult)
#;Close the connection and free the LDAP in memory structures.
 i $d(LD) d ##Class(%SYS.LDAP).UnBinds(LD)
 q Status
Error s $zt=""
 s Status="1,Cache error: "_$ze
 g Done
}
#;
#;----------------------------------------------------------------------------
#;EXAMPLE 2
#;Retrieve and display the root DSE information from the LDAP server. Note that
#;we do not need to bind to the server with a username and password to retrieve
#;this information.
#;----------------------------------------------------------------------------
#;
EXAMPLE2() Public {
 s $zt="Error"
 w !,"Initializing LDAP connection to "_$$$LDAPServer
 s LD=##Class(%SYS.LDAP).Init($$$LDAPServer)
 i LD=0 s Status=##Class(%SYS.LDAP).GetLastError() w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) q
#;We are allowed to connect and search the root DSE without binding. Get all the
#;attributes.
 w !,"Searching Root DSE"
 s Filter="(objectclass=*)"
#;Get all attributes
 s Attributes=""
 s Status=##Class(%SYS.LDAP).SearchExts(LD,"",$$$LDAPSCOPEBASE,Filter,Attributes,0,"","",10,1,.SearchResult)
 i Status'=$$$LDAPSUCCESS w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g Done
#;Set the pointer to the first (and only) entry
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g Done
#;Now loop through all the entries of the Root DSE and display them
 w !,"Displaying Root DSE info:"
 d DisplayAttributes(LD,CurrentEntry)
 w !!,"Done"
Done
 i $d(SearchResult) s Status=##Class(%SYS.LDAP).MsgFree(SearchResult)
 i $d(LD) s Status=##Class(%SYS.LDAP).UnBinds(LD)
 q
Error s $zt=""
 w !,"Cache error: "_$ze
 g Done
}
#;
#;----------------------------------------------------------------------------
#;EXAMPLE 3
#;Connect to a Unix LDAP server, search and display the Root DSE. Bind to the server
#;with root privileges so we can MODIFY the contents of the LDAP database. Now add
#;a new user, and perform several different types of modifications to him. Then search
#;for and display the attributes of the newly added user. Finally, search for and
#;display the DN and objectClass attribute of up to 100 users which may already exist
#;in the database, then rename and delete the just added user.
#;Note: This test assumes that the following schema definitions have been added to the
#;unix LDAP server; This is most simply done by putting this in a file called cache.schema
#;in /etc/openldap/schema, and using it in an include statement in
#;/etc/openldap/slapd.conf. Note that the oid #'s and names below are the ones InterSystems
#;has registered. You can either use these oids, define your own oid's, or use existing
#;oid's in your schema.
#;
#; Attribute Type Definitions
#;
#; attributetype ( 1.2.840.113556.1.8000.2448.2.1 NAME 'intersystem-Routine'
#;         DESC 'InterSystems Routine'
#;         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{128} SINGLE-VALUE )
#;
#; attributetype ( 1.2.840.113556.1.8000.2448.2.2 NAME 'intersystems-Namespace'
#;         DESC 'InterSystems Namespace'
#;         SYNTAX 1.3.6.1.4.1.1466.115.121.1.5 SINGLE-VALUE )
#;
#; attributetype ( 1.2.840.113556.1.8000.2448.2.1 NAME 'intersystems-Roles'
#;         EQUALITY caseIgnoreMatch
#;         DESC 'InterSystems Roles'
#;         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
#;
#; Object Class Definitions
#;
#; objectclass ( 1.2.840.113556.1.8000.2448.1.1 NAME 'intersystemsAccount' SUP top AUXILIARY
#;         DESC 'Abstraction of an account with InterSystems attributes'
#;         MAY ( intersystems-Routine $ interSystems-Namespace $ intersystems-Roles) )
#;
#;----------------------------------------------------------------------------
#;
EXAMPLE3() Public {
 s $zt="Error"
 w !,"Initializing LDAP connection to "_$$$LDAPServer
 s LD=##Class(%SYS.LDAP).Init($$$LDAPServer)
 i LD=0 s Status=##Class(%SYS.LDAP).GetLastError() w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) q
#;We are allowed to connect and search the root DSE without binding. Get all the
#;attributes.
 w !,"Searching Root DSE"
 s Filter="(objectclass=*)"
#;Get all attributes
 s Attributes=""
 s Status=##Class(%SYS.LDAP).SearchExts(LD,"",$$$LDAPSCOPEBASE,Filter,Attributes,0,"","",10,1,.SearchResult)
 i Status'=$$$LDAPSUCCESS w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Set the pointer to the first (and only) entry
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Now loop through all the entries of the Root DSE and display them
 w !,"Displaying Root DSE info:"
 d DisplayAttributes(LD,CurrentEntry)
 s Status=##class(%SYS.LDAP).SimpleBinds(LD,$$$UnixAdminDN,$$$UnixAdminPassword)
 i Status'=$$$LDAPSUCCESS w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Now create a user called test20 with a password of Testtest20. Note that the
#;password must pass the LDAP server's length and pattern checks.
 s username="test20"
 s password="Testtest20"
#;The user we are going to rename test20 to.
 s newusername="test21"
 Set DN=$$$UnixFilter_"="_username_","_$$$UnixBaseDN
 Set NewDN=$$$UnixFilter_"="_newusername_","_$$$UnixBaseDN
#;First delete the leftover user. Don't test the status because the user may have
#;previously deleted, or may not initially exist.
 w !,"Deleting user "_DN
 s Status=##Class(%SYS.LDAP).DeleteExts(LD,DN,"","")
 w !,"Deleting user "_NewDN
 s Status=##Class(%SYS.LDAP).DeleteExts(LD,NewDN,"","")
 w !,"Adding user "_DN
#;Now set up the list of attributes we are going to add for the new user.
 s Attr1=$lb(0,"objectclass",$lb("account","posixAccount","top","shadowAccount","CacheAccount"))
 s Attr2=$lb(0,$$$UnixFilter,$lb(username))
#; Make the namespace a binary value just to test out that function.
#;It doesn't have to be. Binary values are usually used for thing like images/bit streams.
 s Attr3=$lb(128,"intersystems-Namespace",$lb("%SYS"))
 s Attr4=$lb(0,"intersystems-Routine",$lb("iscRoutine"))
 s Attr5=$lb(0,"intersystems-Roles",$lb("iscRole1","iscRole2"))
 s Attr6=$lb(0,"userPassword",$lb(password))
 s Attr7=$lb(0,"cn",$lb("test20"))
 s Attr8=$lb(0,"uidNumber",$lb(58129))
 s Attr9=$lb(0,"gidNumber",$lb(58129))
 s Attr10=$lb(0,"homeDirectory",$lb("/home/test20"))
 s Attributes=$lb(Attr1,Attr2,Attr3,Attr4,Attr5,Attr6,Attr7,Attr8,Attr9,Attr10)
 s Status=##Class(%SYS.LDAP).AddExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"AddExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Delete intersystems-Routine using replace function"
 s Attr1=$lb(2,"intersystems-Routine",$lb(""))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add intersystems-Routine using replace function"
 s Attr1=$lb(2,"intersystems-Routine",$lb("intersystems-Namespace1"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Delete intersystems-Routine"
 s Attr1=$lb(1,"intersystems-Routine",$lb(""))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add intersystems-Routine"
 s Attr1=$lb(0,"intersystems-Routine",$lb("CacheRoutine2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Delete Role2"
 s Attr1=$lb(1,"intersystems-Roles",$lb("iscRole2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Compare "_$$$UnixFilter_ " attribute"
 s Status=##Class(%SYS.LDAP).CompareExts(LD,DN,$$$UnixFilter,username)
 i Status=6 {
	w !,"Compare OK"
 } else {
	w !,"Compare failed"
	w !,"CompareExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 }
 w !,"Delete Role1"
 s Attr1=$lb(1,"intersystems-Roles",$lb("iscRole1"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role1, Role2"
 s Attr1=$lb(0,"intersystems-Roles",$lb("iscRole1,iscRole2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role3"
 s Attr1=$lb(0,"intersystems-Roles",$lb("iscRole3"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Do a straight delete of cacheRoles
 w !,"Delete intersystems-Roles"
 s Attr1=$lb(1,"intersystems-Roles",$lb(""))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role1, Role2 using replace function"
 s Attr1=$lb(2,"intersystems-Roles",$lb("iscRole1,iscRole2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role 3"
 s Attr1=$lb(0,"intersystems-Roles",$lb("iscRole3"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Searching for user "_username_" information"
#;Ok, now lets search for that user, and display all their attributes.
#;The search will only work if the authenticated user passed in has read
#;access to the LDAP server.
 s Attributes=""
#;sAMAccountname is the unique identifier for a windows active directory
#;LDAP server.
 s Filter=$$$UnixFilter_"="_username
#;Note that I am passing the value of SearchResult (from the last search operation)
#;into the search method. This will cause the memory from the previous search
#;to be freed. I could call MsgFree(SearchResult) instead, or if I wanted to
#;keep the old search active, I could just pass in a new variable to the
#;search method.
 s BaseDN=$$$UnixBaseDN
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,$$$LDAPSCOPESUBTREE,Filter,Attributes,0,"","",60,1,.SearchResult)
 i Status'=$$$LDAPSUCCESS w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 Write !,"Displaying user "_username
 s DN=##Class(%SYS.LDAP).GetDN(LD,CurrentEntry)
 w !,"DN:   "_DN
 d DisplayAttributes(LD,CurrentEntry)
 s Status=##Class(%SYS.LDAP).MsgFree(SearchResult) k SearchResult
 i Status'=$$$LDAPSUCCESS w !,"MsgFree error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Validating user "_username_" credentials"
#;Make sure the password is not null. A null password will actually bind "anonymously"
#;and return success even though it does not match the user's password
 i password="" w !,"SimpleBinds error: password cannot be null" g LDAPError
 s Status=##class(%SYS.LDAP).SimpleBinds(LD,DN,password)
 i Status'=$$$LDAPSUCCESS w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 s Status=##class(%SYS.LDAP).SimpleBinds(LD,$$$UnixAdminDN,$$$UnixAdminPassword)
 i Status'=$$$LDAPSUCCESS w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Now lets do a search for all users, and display the DN's
#;for each of them. Restrict the result set to 100 users.
 w !,"Now displaying up to 100 users"
 s Filter=$$$UnixFilter_"=*"
 s Attributes=$lb("ObjectClass")
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,$$$LDAPSCOPESUBTREE,Filter,Attributes,0,"","",10,50,.SearchResult)
 i Status'=$$$LDAPSUCCESS w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 While (CurrentEntry'=0) {
 	w !,"DN:   "_##Class(%SYS.LDAP).GetDN(LD,CurrentEntry) h 0
	s ObjectClass=##Class(%SYS.LDAP).GetValues(LD,CurrentEntry,"ObjectClass")
 	w !,"ObjectClass: "
 	f i=1:1:$ll(ObjectClass) w $lg(ObjectClass,i)_";"
 	s CurrentEntry=##Class(%SYS.LDAP).NextEntry(LD,CurrentEntry)
 }
 w !,"Renaming user "_username_" to "_newusername
 s Status=##Class(%SYS.LDAP).RenameExts(LD,DN,$$$UnixFilter_"="_newusername,"",1,"","")
 i Status'=$$$LDAPSUCCESS w !,"RenameExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Deleting user "_newusername
 s Status=##Class(%SYS.LDAP).DeleteExts(LD,NewDN,"","")
 i Status'=$$$LDAPSUCCESS w !,"DeleteExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
LDAPError
 i $d(SearchResult) s Status=##Class(%SYS.LDAP).MsgFree(SearchResult)
 i +$d(LD) s Status=##Class(%SYS.LDAP).UnBinds(LD)
 q
Error s $zt=""
 w !,"Cache error: "_$ze
 g LDAPError
}
#;----------------------------------------------------------------------------
#;EXAMPLE 4
#;Example 4 is pretty much the same as Example 3, with the difference being we are
#;connecting to a Windows Active Directory server. We first connect to the LDAP AD
#;server, search and display the Root DSE. Bind to the server
#;with administrator privileges so we can MODIFY the contents of the LDAP database. Now add
#;a new user, and perform several different types of modifications to him.
#;We also change his password. Then search
#;for and display the attributes of the newly added user. Finally, search for and
#;display the DN and objectClass attribute of up to 100 users which may already exist
#;in the database, then rename and delete the just added user.
#;Note: This test assumes that the following schema definitions have been added to the
#;Windows AD LDAP server; Note that the oid #'s and names below are the ones InterSystems
#;has registered. You can either use these oids, define your own oid's, or use existing
#;oid's in your schema.
#;
#; Attribute Type Definitions
#;
#; attributetype ( 1.2.840.113556.1.8000.2448.2.1 NAME 'intersystem-Routine'
#;         DESC 'InterSystems Routine'
#;         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{128} SINGLE-VALUE )
#;
#; attributetype ( 1.2.840.113556.1.8000.2448.2.2 NAME 'intersystems-Namespace'
#;         DESC 'InterSystems Namespace'
#;         SYNTAX 1.3.6.1.4.1.1466.115.121.1.5 SINGLE-VALUE )
#;
#; attributetype ( 1.2.840.113556.1.8000.2448.2.1 NAME 'intersystems-Roles'
#;         EQUALITY caseIgnoreMatch
#;         DESC 'InterSystems Roles'
#;         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
#;
#; Object Class Definitions
#;
#; objectclass ( 1.2.840.113556.1.8000.2448.1.1 NAME 'intersystemsAccount' SUP top AUXILIARY
#;         DESC 'Abstraction of an account with InterSystems attributes'
#;         MAY ( intersystems-Routine $ interSystems-Namespace $ intersystems-Roles) )
#;
#;Change Password notes:
#;There are lots of reasons why you can?t change a password. However, almost all the reasons get
#;grouped into one ldap error, ?Unwilling to perform?.
#;
#;To solve this, you need to look at a couple of things:
#;
#;1)	Password policy on the server. Make sure the password fits the syntax requirements of the server.
#;2)	The server may be set up to only allow one password change a day. So if testing this,
#; 	    it worked the first time, but would fail every time after.
#;3)	The user doing the password change (for a differentuser) must have administrator privilege
#;      on the LDAP server.
#;4)	Make sure the ?user cannot change password? flag is not set
#;5)	Check the password history, it might be a re-use of the same password
#;
#;----------------------------------------------------------------------------
#;
EXAMPLE4() Public {
 s $zt="Error"
 w !,"Initializing LDAP connection to "_$$$LDAPServer
 s LD=##Class(%SYS.LDAP).Init($$$LDAPServer)
 i LD=0 s Status=##Class(%SYS.LDAP).GetLastError() w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Searching Root DSE" h 0
 s Filter="(objectclass=*)"
 s Attributes=""
 s Status=##Class(%SYS.LDAP).SearchExts(LD,"",$$$LDAPSCOPEBASE,Filter,Attributes,0,"","",10,1,.SearchResult)
 i Status'=$$$LDAPSUCCESS w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Set the pointer to the first (and only) entry
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Now loop through all the entries of the Root DSE and display them
 w !,"Displaying Root DSE info:" h 0
 d DisplayAttributes(LD,CurrentEntry)
 s Status=##class(%SYS.LDAP).SimpleBinds(LD,$$$WindowsAdminDN,$$$WindowsAdminPassword)
 i Status'=$$$LDAPSUCCESS w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 s username="test20"
#;Ok, to update the password on a windows AD server is tricky to say the least.
#;First a leading and trailing double quote must be added to it.
#;Then it must be converted to unicode.
#;Then when passed into the modify function, it must be passed in as a binary value,
#;with the "Replace" operation. It must be the only operation contained in the modify call.
#;Note that the user must first be created before the
#;password change can take place, and the password change must take place over an
#;encrypted channel.
 s password="Testtest20"
 s ChangePassword=$zcvt(""""_password_"""","o","UnicodeLittle")
 s newusername="test21"
 Set DN="cn="_username_","_$$$WindowsBaseDN
 Set NewDN="cn="_newusername_","_$$$WindowsBaseDN
 s Attr1=$lb(0,"objectclass",$lb("top","person","organizationalPerson","user"))
 s Attr2=$lb(0,"displayName",$lb(username))
 s Attr3=$lb(0,"sAMAccountName",$lb(username))
#; 512 - Normal account
#; 65536 - Don't expire password
 s Attr4=$lb(0,"userAccountControl",$lb(512+65536))
 s Attributes=$lb(Attr1,Attr2,Attr3,Attr4)
 w !,"Deleting user "_DN
 s Status=##Class(%SYS.LDAP).DeleteExts(LD,DN,"","")
 w !,"Deleting user "_NewDN
 s Status=##Class(%SYS.LDAP).DeleteExts(LD,NewDN,"","")
 w !,"Starting TLS"
 i '$$$ISWINDOWS {
 	s Status=##Class(%SYS.LDAP).SetOption(LD,$$$LDAPOPTXTLSCACERTFILE,$$$UnixCertificateFile)
	i Status'=$$$LDAPSUCCESS w !,"SetOption error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 }
 s Status=##Class(%SYS.LDAP).StartTLSs(LD)
 i Status'=$$$LDAPSUCCESS w !,"StartTLSs error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Adding user "_DN
 s Status=##Class(%SYS.LDAP).AddExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"AddExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Note we are passing this in as Binary, with the replace operator.
 w !,"Updating password"
 s Attr1=$lb(130,"unicodePwd",$lb(ChangePassword))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Delete intersystems-Routine using replace function"
 s Attr1=$lb(1,"intersystems-Routine",$lb(""))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add intersystems-Routine using replace function"
 s Attr1=$lb(1,"intersystems-Routine",$lb("iscRoutine1"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Delete intersystems-Routine"
 s Attr1=$lb(2,"intersystems-Routine",$lb(""))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add intersystems-Routine"
 s Attr1=$lb(0,"intersystems-Routine",$lb("CacheRoutine2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Delete Role2"
 s Attr1=$lb(2,"intersystems-Roles",$lb("iscRole2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Compare "_$$$UnixFilter_ " attribute"
 s Status=##Class(%SYS.LDAP).CompareExts(LD,DN,$$$UnixFilter,username)
 i Status=6 {
	w !,"Compare OK"
 } else {
	w !,"Compare failed"
	w !,"CompareExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 }
 w !,"Delete Role1"
 s Attr1=$lb(2,"intersystems-Roles",$lb("iscRole1"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role1, Role2"
 s Attr1=$lb(0,"intersystems-Roles",$lb("iscRole1,iscRole2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role3"
 s Attr1=$lb(0,"intersystems-Roles",$lb("iscRole3"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Do a straight delete of cacheRoles
 w !,"Delete intersystems-Roles"
 s Attr1=$lb(2,"intersystems-Roles",$lb(""))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role1, Role2 using replace function"
 s Attr1=$lb(1,"intersystems-Roles",$lb("iscRole1,iscRole2"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Add Role 3"
 s Attr1=$lb(0,"intersystems-Roles",$lb("iscRole3"))
 s Attributes=$lb(Attr1)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
 i Status'=$$$LDAPSUCCESS w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Searching for user "_username_" information"
#;Ok, now lets search for that user, and display all their attributes.
#;The search will only work if the authenticated user passed in has read
#;access to the LDAP server.
 s Attributes=""
#;sAMAccountname is the unique identifier for a windows active directory
#;LDAP server.
 s Filter=$$$WindowsFilter_"="_username
#;Note that I am passing the value of SearchResult (from the last search operation)
#;into the search method. This will cause the memory from the previous search
#;to be freed. I could call MsgFree(SearchResult) instead, or if I wanted to
#;keep the old search active, I could just pass in a new variable to the
#;search method.
 s BaseDN=$$$WindowsBaseDN
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,$$$LDAPSCOPESUBTREE,Filter,Attributes,0,"","",60,1,.SearchResult)
 i Status'=$$$LDAPSUCCESS w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 Write !,"Displaying user "_username
 s DN=##Class(%SYS.LDAP).GetDN(LD,CurrentEntry)
 w !,"DN:   "_DN
 d DisplayAttributes(LD,CurrentEntry)
 s Status=##Class(%SYS.LDAP).MsgFree(SearchResult) k SearchResult
 i Status'=$$$LDAPSUCCESS w !,"MsgFree error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Now validate the new password we set for them. Note that this leaves this LDAP
#;connection running with the user's credentials.
 w !,"Validating user "_username_" credentials"
 i password="" w !,"SimpleBinds error: password cannot be null" g LDAPError
 s Status=##class(%SYS.LDAP).SimpleBinds(LD,DN,password)
 i Status'=$$$LDAPSUCCESS w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Now rebind so we get back to using the administrator credentials
 s Status=##class(%SYS.LDAP).SimpleBinds(LD,$$$WindowsAdminDN,$$$WindowsAdminPassword)
 i Status'=$$$LDAPSUCCESS w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
#;Now lets do a search for all users, and display the DN's
#;for each of them. Restrict the result set to 100 users.
 w !,"Now displaying up to 100 users"
 s Filter=$$$WindowsFilter_"=*"
 s Attributes=$lb("ObjectClass")
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,$$$LDAPSCOPESUBTREE,Filter,Attributes,0,"","",10,50,.SearchResult)
 i Status'=$$$LDAPSUCCESS w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 While (CurrentEntry'=0) {
 	w !,"DN:   "_##Class(%SYS.LDAP).GetDN(LD,CurrentEntry) h 0
	s ObjectClass=##Class(%SYS.LDAP).GetValues(LD,CurrentEntry,"ObjectClass")
 	w !,"ObjectClass: "
 	f i=1:1:$ll(ObjectClass) w $lg(ObjectClass,i)_";"
 	s CurrentEntry=##Class(%SYS.LDAP).NextEntry(LD,CurrentEntry)
 }
 w !,"Renaming user "_username_" to "_newusername
 s Status=##Class(%SYS.LDAP).RenameExts(LD,DN,"cn="_newusername,"",1,"","")
 i Status'=$$$LDAPSUCCESS w !,"RenameExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
 w !,"Deleting user "_newusername
 s Status=##Class(%SYS.LDAP).DeleteExts(LD,NewDN,"","")
 i Status'=$$$LDAPSUCCESS w !,"DeleteExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) g LDAPError
LDAPError
 i $d(SearchResult) s Status=##Class(%SYS.LDAP).MsgFree(SearchResult)
 i +$d(LD) s Status=##Class(%SYS.LDAP).UnBinds(LD)
 q
Error s $zt=""
 w !,"Cache error: "_$ze
 g LDAPError
}
#;Generic routine to display the attributes of the currently selected entry
#;in the search result.
DisplayAttributes(LD,CurrentEntry) Private {
 s Attribute=##Class(%SYS.LDAP).FirstAttribute(LD,CurrentEntry,.Ptr)
 while (Attribute'="") {
 	s Values=##Class(%SYS.LDAP).GetValues(LD,CurrentEntry,Attribute)
 	w !,Attribute_": "
 	s String=""
 	f i=1:1:$ll(Values) s String=$g(String)_$li(Values,i)_";"
	w String
	s Attribute=##Class(%SYS.LDAP).NextAttribute(LD,CurrentEntry,.Ptr)
 }
 q
}
#;
#;----------------------------------------------------------------------------
#;EXAMPLE 5
#;This example shows how a process on a Windows or Unix client can change their
#;own password on a Windows Active Directory LDAP server. This must be done
#;over a secure connection, and requires the old and new passwords.
#;----------------------------------------------------------------------------
EXAMPLE5() Public {
 s $zt="Error"
 w !,"Change password"
 Read !,"Username: ",Username
 u 0:(:"+S")
 Read !,"Old password: ",OldPassword
 u 0:(:"-S")
 w !
 u 0:(:"+S")
 Read !,"New password: ",NewPassword
 u 0:(:"-S")
 w !
 u 0:(:"+S")
 Read !,"Enter New password again: ",NewPassword1
 u 0:(:"-S")
 i NewPassword'=NewPassword1 {
	 w !,"Password does not match"
	 q
 }
 i $$$WindowsCacheClient {
#;This shows how we initially bind on port 636 from a windows client to a Windows AD
#;server. Instead of this we could have modified the logic to use the unix style
#;client connection (Starttls/Simplebinds) below.
#;Bind on port 636. The certificate must be loaded into the certificate store already.
	s LD=##Class(%SYS.LDAP).Init($$$LDAPServer,636)
 	i LD=0 {
	 	s Status=##Class(%SYS.LDAP).GetLastError()
	 	w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	 	q
 	}
 	s Status=##Class(%SYS.LDAP).Binds(LD,"",$lb(Username,$$$WindowsDomain,OldPassword),$$$LDAPAUTHNEGOTIATE)
 	i Status'=$$$LDAPSUCCESS {
	 	w !,"Binds error: "_Status_" -"_##Class(%SYS.LDAP).Err2String(Status)
	 	g LDAPError
 	}
 } else {
#;Unix style client connection
	s LD=##Class(%SYS.LDAP).Init($$$LDAPServer)
 	i LD=0 s Status=##Class(%SYS.LDAP).GetLastError() w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status) q
	s Status=##Class(%SYS.LDAP).SetOption(LD,$$$LDAPOPTXTLSCACERTFILE,$$$UnixCertificateFile)
	i Status'=$$$LDAPSUCCESS {
		w !,"SetOption(certificate) error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
 		g LDAPError
	}
#;Turn on TLS. This forms the connection, and exchanges the certificate, and makes this a
#;secure connection.
#;Error -11 or -12 most likely means that the certificate has a problem, or possibly
#;the value for LDAPServer is not correct or the right format in the LDAP_Init call. If you have
#;problems getting this to work, you can run the server in debug mode as described above, and
#;watch the debug messages on the server as the certificates exchange between the machines.
	s Status=##Class(%SYS.LDAP).StartTLSs(LD)
	i Status'=$$$LDAPSUCCESS {
		w !,"StartTLS error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
		g LDAPError
 	}
	s Status=##class(%SYS.LDAP).SimpleBinds(LD,$$$WindowsAdminDN,$$$WindowsAdminPassword)
	i Status'=$$$LDAPSUCCESS {
		w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
		g LDAPError
	}
 }
#;Ok, now lets search for that user, and get the DN so we can modify it.
#;access to the LDAP server.
 s Attributes=""
#;sAMAccountname is the unique identifier for a windows active directory
#;LDAP server.
 s Filter=$$$WindowsFilter_"="_Username
 s BaseDN=$$$WindowsBaseDN
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,$$$LDAPSCOPESUBTREE,Filter,Attributes,0,"","",60,1,.SearchResult)
 i Status'=$$$LDAPSUCCESS {
	 w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	 g LDAPError
 }
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 {
	 s Status=##Class(%SYS.LDAP).GetError(LD)
	 w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	 g LDAPError
 }
 s DN=##Class(%SYS.LDAP).GetDN(LD,CurrentEntry)
#;Password change requires the old password and the new password be sent in the
#;same modify operation. Both password need to be in quotes, and unicode encoded.
#;Both must be sent as a binary operation, with the delete operation on the old
#;password, and the add operation on the new password.
 s ChangeOldPassword=$zcvt(""""_OldPassword_"""","o","UnicodeLittle")
 s ChangeNewPassword=$zcvt(""""_NewPassword_"""","o","UnicodeLittle")
 s Attr1=$lb(129,"unicodePwd",$lb(ChangeOldPassword))
 s Attr2=$lb(128,"unicodePwd",$lb(ChangeNewPassword))
 s Attributes=$lb(Attr1,Attr2)
 s Status=##Class(%SYS.LDAP).ModifyExts(LD,DN,Attributes,"","")
#;Note that we can get a bunch of errors here. Error 19 is often used as a catchall
#;for most of them, and most likely means one of the following:
#;1) Password did not meet the length or pattern requirements of the LDAP server
#;2) User cannot change password because their account on the AD server is set this way
#;3) Not enough privileges to change password on the AD Server
#;4) Old password is incorrect
#;5) Number of password changes per day is limited on the AD Server
 i Status'=$$$LDAPSUCCESS {
	 w !,"ModifyExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	 g LDAPError
 }
 w !,"Password changed"
 w !,"Validating password change"
 s Status=##class(%SYS.LDAP).SimpleBinds(LD,DN,NewPassword)
 i Status'=$$$LDAPSUCCESS {
	 w !,"SimpleBinds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	 g LDAPError
 }
 w !,"Validated ok"
LDAPError
 i $d(SearchResult) s Status=##Class(%SYS.LDAP).MsgFree(SearchResult)
 i +$d(LD) s Status=##Class(%SYS.LDAP).UnBinds(LD)
 q
Error s $zt=""
 w !,"Cache error: "_$ze
 g LDAPError
}
#;----------------------------------------------------------------------------
#;EXAMPLE 6
#;NOTE: Use of the %Net.LDAP class has been deprecated. For new development,
#;use the %SYS.LDAP class methods.
#;This example is almost identical to EXAMPLE3 above, except that it uses the
#;old %Net.LDAP classes.
#;----------------------------------------------------------------------------
EXAMPLE6() Public {
 s $zt="Error"
 Set err=""
 Set session=##class(%Net.LDAP.Client.Session).%New()
 w !,"Connecting to "_$$$LDAPServer
 Set c=session.Connect($$$LDAPServer,0,$$$UnixAdminDN,$$$UnixAdminPassword, 0)
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 s username="test20"
 s password="Testtest20"
#;The user we are going to rename test20 to.
 s newusername="test21"
 Set DN=$$$UnixFilter_"="_username_","_$$$UnixBaseDN
 Set NewDN=$$$UnixFilter_"="_newusername_","_$$$UnixBaseDN
 W !,"Deleting user "_DN
 Set c=session.DeleteEntry(DN)
 W !,"Deleting user "_NewDN
 Set c=session.DeleteEntry(NewDN)
 w !,"Adding user "_DN
 Set p=session.GetPropList()
 s v=session.GetValueList()
 s c=v.Insert("account")
 s c=v.Insert("top")
 s c=v.Insert("CacheAccount")
 s c=p.InsertValue("objectclass",v)
 Set c=p.Insert("uid",username) w:(c'=$$$OK) "uid attrib insert failed!!",!
#;1 means binary
 Set c=p.Insert("intersystems-Namespace","Binarysingle",1) w:(c'=$$$OK) "binary attrib insert failed!!",!
 s c=p.Insert("CacheRoutine","CacheRoutine") w:(c'=$$$OK) "CacheRoutine attrib insert failed!!",!
 s v1=session.GetValueList()
 s c=v1.Insert("Role1")
 s c=v1.Insert("Role2")
 s c=p.InsertValue("cacheRoles",v1)
#;1 means binary here
 s v2=session.GetValueList(1)
 s c=v2.Insert("Binarymult1")
 s c=v2.Insert("Binarymult2")
 s c=p.InsertValue("intersystems-Roles",v2)
 Set c=session.AddNewEntry(DN,p)
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Delete CacheRoutine using replace function"
 s ed=session.EditEntry(DN)
 s c=ed.Replace("CacheRoutine","")
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Add CacheRoutine using replace function"
 s ed=session.EditEntry(DN)
 s c=ed.Replace("CacheRoutine","CacheRoutine1")
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
#;Do a straight delete of CacheRoutine
 w !,"Delete CacheRoutine"
 s ed=session.EditEntry(DN)
 s c=ed.Remove("CacheRoutine","")
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
#;Do an add of CacheRoutine back in
 w !,"Add CacheRoutine"
 s ed=session.EditEntry(DN)
 s c=ed.Add("CacheRoutine","CacheRoutine2")
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Delete Role2"
 s ed=session.EditEntry(DN)
 s c=ed.Remove("cacheRoles","Role2")
 s c=ed.Commit()
 w !,"Comparing attribute uid"
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 s c=session.CompareEntryValue(DN,"uid",username)
 If $$$ISERR(c) {
	w !,"Compare failed"
	Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 } else {
	w !,"Compare OK"
 }
 w !,"Delete Role1"
 s ed=session.EditEntry(DN)
 s c=ed.Remove("cacheRoles","Role1")
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Add Role1, Role2"
 s ed=session.EditEntry(DN)
 s v2=session.GetValueList()
 s c=v2.Insert("Role1")
 s c=v2.Insert("Role2")
 s c=ed.Add("cacheRoles",v2)
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Add Role3"
 s ed=session.EditEntry(DN)
 s v2=session.GetValueList()
 s c=v2.Insert("Role3")
 s c=ed.Add("cacheRoles",v2)
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Delete cacheRoles"
 s ed=session.EditEntry(DN)
 s c=ed.Remove("cacheRoles","")
 s c=ed.Commit()
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Add Role1, Role2 using replace function"
 s ed=session.EditEntry(DN)
 s v2=session.GetValueList()
 s c=v2.Insert("Role1")
 s c=v2.Insert("Role2")
 s c=ed.Replace("cacheRoles",v2)
 s c=ed.Commit()
 w !,"Adding Role3"
 s ed=session.EditEntry(DN)
 s v2=session.GetValueList()
 s c=v2.Insert("Role3")
 s c=ed.Add("cacheRoles",v2)
 s c=ed.Commit()
 Set sl=session.GetStringList()
 Do sl.InsertStr("*")
 Set session.MaxItems=100  ;; specify max number of results
 s BaseDN="dc=iscinternal,dc=com"
 s Filter="uid="_username
 w !,"Searching for user "_username_" information"
 Set ents=session.Search(BaseDN,$$$LDAPSCOPESUBTREE, Filter,sl,1000)
 If ('$IsObject(ents)) Do DecomposeStatus^%apiOBJ(ents,.err) Write !,"err : ", err(err) g LDAPError1
 Write !,"Displaying user "_username
 Set entDN=""
 For  { ; iterate through returned entries
	Set ent=ents.GetNext(.entDN)
	Quit:(entDN="")
	w !,"DN:   "_ent.GetDN()
	d DisplayAttributes1(ent)
 }
 w !,"Now displaying up to 100 users"
 Set sl=session.GetStringList()
 Do sl.InsertStr("ObjectClass")
 Set session.MaxItems=100  ;; specify max number of results
 s BaseDN="dc=iscinternal,dc=com"
 s Filter="uid=*"
 Set ents=session.Search(BaseDN,$$$LDAPSCOPESUBTREE, Filter,sl,1000)
 If ('$IsObject(ents)) Do DecomposeStatus^%apiOBJ(ents,.err) Write !,"err : ", err(err) g LDAPError1
 Set entDN=""
 For  { ; iterate through returned entries
	Set ent=ents.GetNext(.entDN)
	Quit:(entDN="")
	w !,"DN:   "_ent.GetDN()
	d DisplayAttributes1(ent)
 }
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 w !,"Renaming user "_username_" to "_newusername
 s c=session.RenameEntry(DN,"uid="_newusername,"",1)
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
 W !,"Deleting user "_NewDN
 Set c=session.DeleteEntry(NewDN)
 If $$$ISERR(c) Do DecomposeStatus^%apiOBJ(c,.err) Write !,"err : ", err(err) g LDAPError1
LDAPError1
 q
DisplayAttributes1(ent)
 Set attrNM=""
 For  { ; iterate through each attribute of an entry
	Set val=ent.GetNext(.attrNM)
	Quit:(attrNM="")
	Write !,attrNM_":  "
	For i=1:1:val.GetNumItems() {
		Write val.GetValue(i)_";"
	}
	h 0
 }
 Quit  ;; list end
Error s $zt=""
 w !,"Cache error: "_$ze
 g LDAPError1
}
#;----------------------------------------------------------------------------
#;EXAMPLE 7
#;This example shows how you can connect from a windows client to a windows active directory ldap server,
#;and using groups, see if a specific user is a member of that group. Based on the group
#;they are in, you can then assign roles. This could be the basis for a delegated authentication routine.
#;----------------------------------------------------------------------------
EXAMPLE7() Public {
 s $zt="Error"
 read !,"Username? ",Username q:Username=""
#;We need to trap all errors so we can close the LDAP channel, otherwise a memory
#;leak can occur.
#;The following line sets up the internal LDAP structures. Note that we are using
#;a secure connection since a password will be sent. The CA certificate needs to
#;be already loaded.
 s LD=##Class(%SYS.LDAP).Init($$$LDAPServer,636)
 i LD=0 {
	s Status=##Class(%SYS.LDAP).GetLastError()
	w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	g Done
 }
#;Ok, now we bind (authenticate) to the server using the credentials of the LDAP administrator
#;who has read access to the entire LDAP database. We need to do this first so we have
#;privileges to search for the user we want to authenticate.
 s Status=##Class(%SYS.LDAP).Binds(LD,"",$lb($$$WindowsAdminUser,$$$WindowsDomain,$$$WindowsAdminPassword),$$$LDAPAUTHNEGOTIATE)
 i Status'=$$$LDAPSUCCESS {
	w !,"Binds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	g Done
 }
#;Now that we have read access to the LDAP server, we need to search the LDAP
#;database for the user we want to authenticate in order to get their info.
#;Set up the Filter to be the unique identify for the user in the LDAP database, plus
#;add the group filter to it.
#;Note that we cannot wildcard the memberOf attribute on a windows AD server.
 s Filter="(&("_$$$WindowsFilter_"="_Username_")"_$$$GroupFilter_")"
#;$$$LDAPSCOPESUBTREE means to search the entire tree beneath the BaseDN used.
 s SearchScope=$$$LDAPSCOPESUBTREE
#;Max length of time the search can last.
 s Timeout=10
#;Return just the first thing we find.
 s SizeLimit=1
 s Status=##Class(%SYS.LDAP).SearchExts(LD,$$$WindowsBaseDN,SearchScope,Filter,"",0,"","",Timeout,SizeLimit,.SearchResult)
 i Status'=$$$LDAPSUCCESS {
#;If we got a funny username entered by the user, we may have a bad filter. Note that on some LDAP
#;implementations, if you get an error here, you cannot recover. You must shut down the connection
#;(unbind), and call LDAP_Init/Bind again. If you don't, you may CORE at some later time.
	i Status=$$$XLDAPFILTERERROR {
		w !,"User "_Username_" does not exist"
	} else {
		w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	}
	g Done
 }
#;See how many entries were returned by the search.
 s NumEntries=##Class(%SYS.LDAP).CountEntries(LD,SearchResult)
 i NumEntries=-1 {
	s Status=##Class(%SYS.LDAP).GetError(LD)
	w !,"CountEntries error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	g Done
 }
#;If NumEntries=0, then either there is no LDAP user for the username
#;in the database, the user was found but is not a member of the group,
#;or the BaseDN parameter needs to be set higher in the tree.
 i NumEntries=0 {
	w !,"User "_Username_" does not exist, or is not a member of the group"
 	g Done
 }
#;If the search returned too many items, then the Filter is probably wrong.
 i NumEntries>1 {
	w !,"LDAP Filter is not unique"
 	g Done
 }
#;If here, we found a matching user who is a member of the group.
 w !,"Username "_Username_" is a member of the group"
Done
#;We must free the search buffer here otherwise future LDAP calls may core
#;or memory leak.
 i $d(SearchResult) d ##Class(%SYS.LDAP).MsgFree(SearchResult)
#;Close the connection and free the LDAP in memory structures.
 i $d(LD) d ##Class(%SYS.LDAP).UnBinds(LD)
 q
Error s $zt=""
 w !,"Cache error: "_$ze
 g Done
}
#;----------------------------------------------------------------------------
#;EXAMPLE 8
#;This example shows how you can connect from a windows client to a windows active directory ldap server,
#;and return all the groups the user is a member of.
#;----------------------------------------------------------------------------
EXAMPLE8() Public {
#define LDAPServer "CAMBDC1"
#define WindowsDomain "iscinternal.com"
#define WindowsBaseDN "dc=iscinternal,dc=com"
 s $zt="Error"
 read !,"Username? ",Username q:Username=""
 u 0:(:"+S")
 Read !,"Password: ",Password
 u 0:(:"-S")
#;This shows how we initially bind on port 636 from a windows client to a Windows AD
#;server. Instead of this we could have modified the logic to use the unix style
#;client connection (Starttls/Simplebinds) below.
#;Bind on port 636. The certificate must be loaded into the certificate store already.
 s LD=##Class(%SYS.LDAP).Init($$$LDAPServer,636)
 i LD=0 {
 	s Status=##Class(%SYS.LDAP).GetLastError()
 	w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
 	q
 }
 s Status=##Class(%SYS.LDAP).Binds(LD,"",$lb(Username,$$$WindowsDomain,Password),$$$LDAPAUTHNEGOTIATE)
 i Status'=$$$LDAPSUCCESS {
 	w !,"Binds error: "_Status_" -"_##Class(%SYS.LDAP).Err2String(Status)
 	g Done
 }
#;Get the non-nested groups by returning the memberOf Attribute
 s Attributes=$lb("memberOf")
#;sAMAccountname is the unique identifier for a windows active directory
#;LDAP server.
 s Filter=$$$WindowsFilter_"="_Username
 s BaseDN=$$$WindowsBaseDN
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,$$$LDAPSCOPESUBTREE,Filter,Attributes,0,"","",60,1,.SearchResult)
 i Status'=$$$LDAPSUCCESS {
	 w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	 g Done
 }
 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 i CurrentEntry=0 {
	 s Status=##Class(%SYS.LDAP).GetError(LD)
	 w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	 g Done
 }
 s DN=##Class(%SYS.LDAP).GetDN(LD,CurrentEntry)
 s memberOf=##Class(%SYS.LDAP).GetValues(LD,CurrentEntry,$li(Attributes,1))
 s Status=##Class(%SYS.LDAP).GetError(LD)
#;Decoding error is the new error code for nosuchattribute
 i (Status'=$$$LDAPSUCCESS),(Status'=$$$LDAPNOSUCHATTRIBUTE),(Status'=$$$LDAPDECODINGERROR),(Status'=$$$XLDAPDECODINGERROR) {
	g Done
 }
 w !
 w !,"Found "_$ll(memberOf)_" groups for user "_Username
 w !,"Member Of Group:"
 f i=1:1:$ll(memberOf) {
	 w !,$li(memberOf,i)
 }

#;This is a special filter which allows us to return nested groups. It is important to include the
#;objectclass filter here since it is usually indexed by the ldap server and speeds up the search
 s GroupFilter="(&(objectClass=group)(member:1.2.840.113556.1.4.1941:="_DN_"))"
#;If this were Unix, we would use the following filter
#; s GroupFilter="(&(objectClass=groupOfNames)(member:1.2.840.113556.1.4.1941:="_DN_"))"
 s GroupAttributes=""
 s Status=##Class(%SYS.LDAP).SearchExts(LD,BaseDN,$$$LDAPSCOPESUBTREE,GroupFilter,GroupAttributes,0,"","",10,0,.GroupSearchResult)
 i Status'=$$$LDAPSUCCESS {
	w !,"SearchExts error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	g Done
 }
 s GroupNumEntries=##Class(%SYS.LDAP).CountEntries(LD,GroupSearchResult)
 i GroupNumEntries=-1 {
	s Status=##Class(%SYS.LDAP).GetError(LD)
	w !,"CountEntries Group error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	g Done
 }
#;See if there is no LDAP user for this user, or the search returned
#;too many items. If the search returned too many items, then the
#;UniqueDNIdentifier is probably wrong.
 w !
 i GroupNumEntries=0 {
	w !,"No nested groups for "_Username_" found"
	g Done
 }
 i GroupNumEntries>0 {
	w !,"Found "_GroupNumEntries_" nested groups for user "_Username
 }
 w !,"Member Of Nested Group:"
#;Get the dn of the first entry returned.
 s GroupCurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,GroupSearchResult)
 i GroupCurrentEntry=0 {
	s Status=##Class(%SYS.LDAP).GetError(LD)
	w !,"FirstEntry error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	g Done
 }
 s Groups=""
 While (GroupCurrentEntry'=0) {
	s GroupDN=##Class(%SYS.LDAP).GetDN(LD,GroupCurrentEntry)
	i GroupDN="" {
		s Status=##Class(%SYS.LDAP).GetError(LD)
		w !,"GetDN Group error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
		q
	}
#;Save for later display
	w !,GroupDN
 	s GroupCurrentEntry=##Class(%SYS.LDAP).NextEntry(LD,GroupCurrentEntry)
 }
Done
 i $d(SearchResult) d ##Class(%SYS.LDAP).MsgFree(SearchResult)
 i $d(GroupSearchResult) d ##Class(%SYS.LDAP).MsgFree(GroupSearchResult)
#;Close the connection and free the LDAP in memory structures.
 i $d(LD) d ##Class(%SYS.LDAP).UnBinds(LD)
 q
Error s $zt=""
 w !,"Cache error: "_$ze
 g Done
}
#;----------------------------------------------------------------------------
#;EXAMPLE 9
#;This example shows how a process on a Windows client can use paged searches
#;to return a large amount of records from a windows ldap server.
#;----------------------------------------------------------------------------
EXAMPLE9() Public {
 s $zt="Error"
 s $ze=""
 s LD=##Class(%SYS.LDAP).Init($$$LDAPServer,389)
 i LD=0 {
	s Status=##Class(%SYS.LDAP).GetLastError()
	w !,"Init error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	q Status
 }
#;Ok, now we bind (authenticate) to the server using the credentials of the LDAP administrator
#;who has read access to the entire LDAP database. We need to do this first so we have
#;privileges to search for the user we want to authenticate.
 s Status=##Class(%SYS.LDAP).Binds(LD,"",$lb($$$WindowsAdminUser,$$$WindowsDomain,$$$WindowsAdminPassword),$$$LDAPAUTHNEGOTIATE)
 i Status'=$$$LDAPSUCCESS {
	w !,"Binds error: "_Status_" - "_##Class(%SYS.LDAP).Err2String(Status)
	q Status
 }
#;Return all users, along with their phone number and e-mail
 s Filter="sAMAccountname=*"
 s Attributes=$lb("displayName","telephoneNumber","mail")
 s Page=##Class(%SYS.LDAP).SearchInitPage(LD,$$$WindowsBaseDN,$$$LDAPSCOPESUBTREE,Filter,Attributes,0,"","",10,100,"")
#;For each page, return 100 records
 s Status=##Class(%SYS.LDAP).GetNextPages(LD,Page,10,100,.TotalPages,.SearchResult)
 s PageCount=1
 While (Status=$$$LDAPSUCCESS) {
	 s CurrentEntry=##Class(%SYS.LDAP).FirstEntry(LD,SearchResult)
 	i CurrentEntry=0 s Status=##Class(%SYS.LDAP).GetError(LD) return Status
 	While (CurrentEntry'=0) {
 		d GetUserAttributes(LD,CurrentEntry,.Attributes)
		s ^PhoneList($i(^PhoneList))=$lb(Attributes("displayName"),Attributes("telephoneNumber"),Attributes("mail"))
 		s CurrentEntry=##Class(%SYS.LDAP).NextEntry(LD,CurrentEntry)
 	}
	s Status=##Class(%SYS.LDAP).GetNextPages(LD,Page,10,100,.TotalPages,.SearchResult)
 	s PageCount=PageCount+1
 }
Done
 i $d(SearchResult) d ##Class(%SYS.LDAP).MsgFree(SearchResult)
 i $d(Page) d ##Class(%SYS.LDAP).SearchAbandonPage(LD,Page)
 i Status=$$$LDAPNORESULTSRETURNED s Status=0 ;success
 i $d(LD) s Status=##Class(%SYS.LDAP).UnBinds(LD)
 q Status
Error s $zt=""
 w !,"Cache error: "_$ze
 g Done
}
GetUserAttributes(LD,CurrentEntry,Attributes) Private {
 k Attributes
 s (Attributes("telephoneNumber"),Attributes("mail"),Attributes("displayName"))=""
 s Attribute=##Class(%SYS.LDAP).FirstAttribute(LD,CurrentEntry,.Ptr)
 while (Attribute'="") {
 	s Values=##Class(%SYS.LDAP).GetValues(LD,CurrentEntry,Attribute)
 	s Attributes(Attribute)=$li(Values)
 	s Attribute=##Class(%SYS.LDAP).NextAttribute(LD,CurrentEntry,.Ptr)
 }
}


