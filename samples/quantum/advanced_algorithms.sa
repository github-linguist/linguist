# Advanced Quantum Algorithms - Mathematical and Computational Excellence
# MIT License - Sophisticated algorithm implementations in Quantum language

# Mathematical constants and utilities
const PI = 3.141592653589793
const E = 2.718281828459045
const GOLDEN_RATIO = 1.618033988749895
const EPSILON = 1e-10

# Advanced sorting algorithms
fn quantum_quick_sort(arr, low, high) {
    if low < high {
        let pivot_index = quantum_partition(arr, low, high)
        quantum_quick_sort(arr, low, pivot_index - 1)
        quantum_quick_sort(arr, pivot_index + 1, high)
    }
}

fn quantum_partition(arr, low, high) {
    let pivot = arr[high]
    let i = low - 1
    
    for j in range(low, high) {
        if arr[j] <= pivot {
            i += 1
            # Swap elements
            let temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        }
    }
    
    # Final swap
    let temp = arr[i + 1]
    arr[i + 1] = arr[high]
    arr[high] = temp
    
    return i + 1
}

fn merge_sort(arr) {
    if len(arr) <= 1:
        return arr
    
    let mid = floor(len(arr) / 2)
    let left = merge_sort(arr.slice(0, mid))
    let right = merge_sort(arr.slice(mid))
    
    return merge(left, right)
}

fn merge(left, right) {
    let result = []
    let i = 0
    let j = 0
    
    while i < len(left) and j < len(right) {
        if left[i] <= right[j]:
            result.push(left[i])
            i += 1
        else:
            result.push(right[j])
            j += 1
    }
    
    # Add remaining elements
    while i < len(left):
        result.push(left[i])
        i += 1
    
    while j < len(right):
        result.push(right[j])
        j += 1
    
    return result
}

# Graph algorithms
fn dijkstra(graph, start_node) {
    let distances = {}
    let visited = {}
    let previous = {}
    let nodes = graph.keys()
    
    # Initialize distances
    for node in nodes {
        distances[node] = INF
        visited[node] = false
        previous[node] = nil
    }
    distances[start_node] = 0
    
    for i in range(len(nodes) - 1) {
        let current_node = get_min_distance_node(distances, visited)
        visited[current_node] = true
        
        for neighbor in graph[current_node].keys() {
            if not visited[neighbor]:
                let distance = distances[current_node] + graph[current_node][neighbor]
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_node
            }
        }
    }
    
    return {"distances": distances, "previous": previous}
}

fn get_min_distance_node(distances, visited) {
    let min_distance = INF
    let min_node = nil
    
    for node in distances.keys():
        if not visited[node] and distances[node] <= min_distance:
            min_distance = distances[node]
            min_node = node
    
    return min_node
}

fn depth_first_search(graph, start_node, visited) {
    if visited == nil:
        visited = {}
    
    visited[start_node] = true
    print("Visited: " + start_node)
    
    for neighbor in graph[start_node] {
        if not visited.has(neighbor):
            depth_first_search(graph, neighbor, visited)
    }
    
    return visited
}

# Mathematical algorithms
fn fibonacci(n) {
    if n <= 1:
        return n
    
    let fib = [0, 1]
    for i in range(2, n + 1) {
        fib.push(fib[i-1] + fib[i-2])
    }
    
    return fib[n]
}

fn fibonacci_recursive(n) {
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
}

fn gcd(a, b) {
    while b != 0:
        let temp = b
        b = a % b
        a = temp
    return a
}

fn lcm(a, b) {
    return abs(a * b) / gcd(a, b)
}

fn is_prime(n) {
    if n <= 1:
        return false
    if n <= 3:
        return true
    if n % 2 == 0 or n % 3 == 0:
        return false
    
    let i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return false
        i += 6
    
    return true
}

fn sieve_of_eratosthenes(n) {
    let primes = [true] * (n + 1)
    primes[0] = primes[1] = false
    
    for i in range(2, floor(sqrt(n)) + 1):
        if primes[i]:
            for j in range(i * i, n + 1, i):
                primes[j] = false
    
    let result = []
    for i in range(2, n + 1):
        if primes[i]:
            result.push(i)
    
    return result
}

# String algorithms
fn kmp_search(text, pattern) {
    let lps = compute_lps(pattern)
    let i = 0  # index for text
    let j = 0  # index for pattern
    let matches = []
    
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
            
            if j == len(pattern):
                matches.push(i - j)
                j = lps[j - 1]
        else:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return matches
}

fn compute_lps(pattern) {
    let lps = [0] * len(pattern)
    let len = 0
    let i = 1
    
    while i < len(pattern):
        if pattern[i] == pattern[len]:
            len += 1
            lps[i] = len
            i += 1
        else:
            if len != 0:
                len = lps[len - 1]
            else:
                lps[i] = 0
                i += 1
    
    return lps
}

fn longest_common_subsequence(str1, str2) {
    let m = len(str1)
    let n = len(str2)
    let dp = array(m + 1, array(n + 1, 0))
    
    # Build the DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Reconstruct the LCS
    let lcs = ""
    let i = m
    let j = n
    
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs = str1[i-1] + lcs
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return lcs
}

# Data structures
class Stack {
    fn init() {
        this.items = []
    }
    
    fn push(item) {
        this.items.push(item)
    }
    
    fn pop() {
        if this.is_empty():
            return nil
        return this.items.pop()
    }
    
    fn peek() {
        if this.is_empty():
            return nil
        return this.items[len(this.items) - 1]
    }
    
    fn is_empty() {
        return len(this.items) == 0
    }
    
    fn size() {
        return len(this.items)
    }
}

class Queue {
    fn init() {
        this.items = []
    }
    
    fn enqueue(item) {
        this.items.push(item)
    }
    
    fn dequeue() {
        if this.is_empty():
            return nil
        return this.items.shift()
    }
    
    fn front() {
        if this.is_empty():
            return nil
        return this.items[0]
    }
    
    fn is_empty() {
        return len(this.items) == 0
    }
    
    fn size() {
        return len(this.items)
    }
}

# Numerical methods
fn newton_raphson(f, df, x0, tolerance, max_iterations) {
    let x = x0
    let iterations = 0
    
    while iterations < max_iterations:
        let fx = f(x)
        let dfx = df(x)
        
        if abs(dfx) < EPSILON:
            break
        
        let x_new = x - fx / dfx
        
        if abs(x_new - x) < tolerance:
            return x_new
        
        x = x_new
        iterations += 1
    
    return x
}

fn trapezoidal_rule(f, a, b, n) {
    let h = (b - a) / n
    let sum = f(a) + f(b)
    
    for i in range(1, n):
        let x = a + i * h
        sum += 2 * f(x)
    
    return sum * h / 2
}

fn simpsons_rule(f, a, b, n) {
    if n % 2 != 0:
        n += 1  # Make n even
    
    let h = (b - a) / n
    let sum = f(a) + f(b)
    
    for i in range(1, n):
        let x = a + i * h
        if i % 2 == 0:
            sum += 2 * f(x)
        else:
            sum += 4 * f(x)
    
    return sum * h / 3
}

# Performance testing utilities
fn benchmark_algorithm(algorithm, data, iterations) {
    let start_time = time()
    
    for i in range(iterations):
        algorithm(data)
    
    let end_time = time()
    let total_time = end_time - start_time
    
    return {
        "algorithm": algorithm,
        "data_size": len(data),
        "iterations": iterations,
        "total_time": total_time,
        "average_time": total_time / iterations
    }
}

fn compare_sorting_algorithms(data) {
    let data_copy1 = data.copy()
    let data_copy2 = data.copy()
    
    let quick_sort_time = benchmark_algorithm(fn(arr) { quantum_quick_sort(arr, 0, len(arr) - 1) }, data_copy1, 100)
    let merge_sort_time = benchmark_algorithm(merge_sort, data_copy2, 100)
    
    return {
        "quick_sort": quick_sort_time,
        "merge_sort": merge_sort_time,
        "winner": quick_sort_time["average_time"] < merge_sort_time["average_time"] ? "quick_sort" : "merge_sort"
    }
}

# Main demonstration
fn run_algorithm_demonstration() {
    print("ðŸ§® Quantum Algorithm Suite Demonstration")
    print("=====================================")
    
    # Test data
    let test_array = [64, 34, 25, 12, 22, 11, 90, 88, 76, 50, 42]
    let test_graph = {
        "A": {"B": 4, "C": 2},
        "B": {"A": 4, "C": 1, "D": 5},
        "C": {"A": 2, "B": 1, "D": 8, "E": 10},
        "D": {"B": 5, "C": 8, "E": 2},
        "E": {"C": 10, "D": 2}
    }
    
    print("\nðŸ“Š Sorting Algorithms:")
    print("Original array: " + str(test_array))
    
    let quick_sorted = test_array.copy()
    quantum_quick_sort(quick_sorted, 0, len(quick_sorted) - 1)
    print("Quick sort: " + str(quick_sorted))
    
    let merge_sorted = merge_sort(test_array.copy())
    print("Merge sort: " + str(merge_sorted))
    
    print("\nðŸ” Graph Algorithms:")
    let dijkstra_result = dijkstra(test_graph, "A")
    print("Shortest paths from A: " + str(dijkstra_result["distances"]))
    
    print("\nðŸ”¢ Mathematical Functions:")
    print("Fibonacci(10): " + str(fibonacci(10)))
    print("GCD(48, 18): " + str(gcd(48, 18)))
    print("LCM(48, 18): " + str(lcm(48, 18)))
    print("Is prime(97): " + str(is_prime(97)))
    print("Primes up to 30: " + str(sieve_of_eratosthenes(30)))
    
    print("\nðŸ”¤ String Algorithms:")
    let text = "ABABDABACDABABCABAB"
    let pattern = "ABABCABAB"
    let matches = kmp_search(text, pattern)
    print("Pattern matches found at positions: " + str(matches))
    
    let lcs_result = longest_common_subsequence("AGGTAB", "GXTXAYB")
    print("Longest Common Subsequence: " + lcs_result)
    
    print("\nðŸ“ˆ Performance Comparison:")
    let large_data = array(1000, 0).map(fn(i) { return rand_int(1, 10000) })
    let performance = compare_sorting_algorithms(large_data)
    print("Winner: " + performance["winner"])
    
    print("\nâœ… Algorithm Demonstration Complete!")
}

# Run the demonstration
run_algorithm_demonstration()
