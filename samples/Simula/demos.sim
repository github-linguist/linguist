comment License: program borrowed from S-PORT https://github.com/portablesimula/S-PORT;
  CLASS DEMOS;
  BEGIN
  COMMENT----D A T A   C O L L E C T I O N   D E V I C E S----
  *
  * THIS LEVEL CONTAINS THE DATA COLLECTING MECHANISMS
  * AND THEIR PRINTING ROUTINES. THE DEFINITIONS ARE:
  *
  *      ACCUMULATE  COUNT  HISTOGRAM  TALLY
  *
  * ACCUMULATE   COLLECTS TIME DEPENDENT DATA
  *
  * COUNT        IS USED TO COUNT INCIDENCES ONLY
  *
  * HISTOGRAM    COLLECTS DATA IN HISTOGRAM FORM AND
  *              PRINTS THE END RESULT AS A PICTURE
  *
  * TALLY        COLLECTS TIME INDEPENDENT DATA
  *
  * ATTRIBUTES SHARED BY THESE DEFINITIONS :
  *              RESET       NOTE TIME AND RESET STATUS
  *                          TO ZERO
  *              UPDATE(V)   RECORD NEW ENTRY V
  *              REPORT      PRINT CURRENT STATUS
  *
  * THESE CLASSES ARE PREFIXED BY 'TAB' WHICH CONTAINS
  * COMMON VARIABLES AND THE PARAMETER 'TITLE' WHICH NAMES
  * THE PARTICULAR OBJECT.
  * EVERY OBJECT OF A CLASS INNER TO TAB IS PUT INTO A
  * 'REPORTQ' BEHIND THE SCENES.
  * THESE REPORTQS ARE SYSTEM DEFINED AND ARE CALLED
  *
  *    ACCUMQ  COUNTQ  DIST(+EMP)Q  HISTOQ  TALLYQ
  *
  * ON A CALL 'REPORT', THE CURRENT STATUSES OF ALL THESE
  * REPORTQS ARE WRITTEN OUT.
  *
  * THE SET OF PREDEFINED DATA COLLECTION FACILITIES
  * IS PREFIXED BY TAB.
  *
  * TAB          DEFINES THE COMMON CORE
  *
  * VARIABLES:
  *              TITLE       USER SUPPLIED DESCRIPTIVE TEXT
  *              OBS         NO. OF ENTRIES SINCE RESETAT
  *              RESETAT     TIME WHEN INITIATED, OR LAST RESET
  *              NEXT        REF TO NEXT TAB IN REPORTQ
  *
  * PROCEDURES:
  *
  *             JOIN        ENTERS THIS TAB INTO A NAMED
  *                         REPORTQ AT THE END
  *
  *             RESET       (VIRTUAL) NOTES THE TIME IN
  *                         RESETAT AND SETS OBS TO ZERO
  *
  *             WRITETRN    PRINTS ON ONE (PART)LINE
  *                         TITLE/RESET TIME/OBSERVATIONS
  *;


  COMMENT------------------ T A B ----------------------------;

  CLASS TAB(TITLE); VALUE TITLE; TEXT TITLE;
          VIRTUAL : PROCEDURE RESET, REPORT;
  BEGIN INTEGER OBS;  REAL RESETAT;
  REF(TAB)NEXT;

  PROCEDURE JOIN(R); REF(REPORTQ)R;
  BEGIN
  IF R == NONE THEN ERROR(18, NONE, THIS TAB, 0,
     "T.JOIN(R); REF(TAB)T; REF(REPORTQ)R;") ELSE
  IF R.FIRST == NONE
    THEN R.FIRST :- R.LAST      :- THIS TAB
    ELSE R.LAST  :- R.LAST.NEXT :- THIS TAB;
  END***JOIN***;

  PROCEDURE REPORT;
  BEGIN
  WRITETRN;
  OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE RESET;
  BEGIN
  OBS     := 0;
  RESETAT := TIME;
  END***RESET***;

  PROCEDURE WRITETRN;
  BEGIN
  OUTF.OUTTEXT(TITLE);
  OUTF.SETPOS(OUTF.POS+(13-TITLE.LENGTH));
  PRINTREAL(RESETAT);
  OUTF.OUTINT(OBS, 7);
  END***REPORT TITLE, RESETAT AND READINGS***;

  IF TITLE.LENGTH > 12 THEN TITLE :- TITLE.SUB(1, 12);
  RESET;
  END***TAB***;

  COMMENT-------------------- T A L L Y -----------------------;

  TAB CLASS TALLY;
  BEGIN                    COMMENT
  *
  * VARIABLES:
  *    .TITLE    USER SUPPLIED DESCRIPTIVE TEXT (PARAMETER)
  *    .OBS      NUMBER OF INCIDENCES
  *    .RESETAT  LAST TIME OF SETTING OR TIME OF CREATION
  *    .NEXT     REF TO .NEXT TAB IN REPORTQ
  *     SUM      SUM OF SAMPLE VALUES
  *     SUMSQ    SUM OF SQUARES OF SAMPLE VALUES
  *    (VARIANCE)(OBS*SUMSQ - SUM*SUM)/(OBS*(OBS-1))
  *    (SIGMA)   SQRT(VARIANCE)
  *     MIN      LEAST SAMPLE VALUE
  *     MAX      LARGEST SAMPLE VALUE
  *
  * PROCEDURES :
  *    RESET     RESETS OBS, SUM, SUMSQ, MIN, MAX TO ZERO
  *              COPIES TIME INTO RESETAT
  *
  *    UPDATE(V) ADDS  1  TO  OBS
  *              ADDS  V  TO  SUM
  *              ADDS V*V TO  SUMSQ
  *              MAX BECOMES MAXIMUM (MAX,V)
  *              MIN BECOMES MINIMUM (MIN,V)
  *
  *    REPORT    PRINTS ON ONE LINE:
  *              TITLE/RESET/OBS/AV/EST.ST.DEV/MIN/MAX
  *;

  REAL SUM, SUMSQ, MIN, MAX;

  PROCEDURE REPORT;
  BEGIN WRITETRN;
  IF OBS = 0 THEN OUTF.OUTTEXT(MINUSES.SUB(1, 40)) ELSE
  BEGIN PRINTREAL(SUM/OBS);
  IF OBS = 1 THEN OUTF.OUTTEXT(MINUSES.SUB(1, 10)) ELSE
    PRINTREAL(SQRT(ABS(OBS*SUMSQ-SUM**2)/(OBS*(OBS-1))));
  PRINTREAL(MIN);
  PRINTREAL(MAX);
  END;
  OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE RESET;
  BEGIN OBS := 0;
  SUM     := SUMSQ  := MIN   := MAX    := 0.0;
  RESETAT := TIME;
  END***RESET***;

  PROCEDURE UPDATE(V); REAL V;
  BEGIN OBS := OBS + 1;
  SUM    := SUM + V;
  SUMSQ  := SUMSQ + V**2;
  IF OBS = 1 THEN MIN := MAX := V ELSE
     IF V < MIN THEN MIN := V ELSE
     IF V > MAX THEN MAX := V;
  END*** UPDATE ***;

  IF NOT(THIS TALLY IS NOTALLY) THEN JOIN(TALLYQ);
  END*** TALLY ***;


  COMMENT NOTALLY IS USED IN HISTOGRAM. NOTALLY OBJECTS ARE
          NOT ENTERED INTO TALLYQ;

  TALLY CLASS NOTALLY;;

  COMMENT------------------ C O U N T -------------------------;

  TAB CLASS COUNT;
  BEGIN                   COMMENT
  *
  * VARIABLES :
  *    .TITLE        USER SUPPLIED DESCRIPTIVE TEXT (PARAMETER)
  *    .OBS          NUMBER OF INCIDENCES
  *    .RESETAT      LAST TIME OF SETTING OR TIME OF CREATION
  *    .NEXT         REF TO NEXT TAB IN REPORTQ
  *
  * PROCEDURES :
  *     .RESET       RESETS OBS TO ZERO
  *                  COPIES TIME INTO RESETAT

  *     UPDATE(V)    ADDS V TO OBS
  *
  *     REPORT       PRINTS ON ONE LINE:
  *                  TITLE/RESET/OBSERVATIONS
  *;

  PROCEDURE REPORT;
  BEGIN
  OUTF.SETPOS(21);
  WRITETRN;
  OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE UPDATE(V); INTEGER V;
  BEGIN
  OBS  := OBS + V;
  END***UPDATE***;

  JOIN(COUNTQ);
  END***COUNT***;

  COMMENT-------------------- A C C U M U L A T E -------------;

  TAB CLASS ACCUMULATE;
  BEGIN                  COMMENT
  *
  * VARIABLES :      **** TIME WEIGHTED ****
  *    .TITLE        USER SUPPLIED DESCRIPTIVE TEXT (PARAM.)
  *    .OBS          NUMBER OF INCIDENCES
  *    .RESETAT      LAST TIME OF SETTING OR TIME OF CREATION
  *    .NEXT         REF TO NEXT TAB IN REPORTQ
  *     SUMT         TIME WEIGHTED SUM
  *     SUMSQT       TIME WEIGHTED SUM OF SQUARES
  *    (MEAN)        SUM/TIMESPAN = (LAST UPDATE TIME-RESETAT)
  *    (SIGMA)       SQRT( SUMSQT / TIMESPAN - MEAN**2)
  *     MIN          LEAST SAMPLE VALUE
  *     MAX          LARGEST SAMPLE VALUE
  *     LASTTIME     TIME OF LAST UPDATE
  *     LASTV        LAST UPDATE VALUE
  *
  * PROCEDURES :
  *     RESET        RESETS OBS, SUM, SUMSQT, MIN, MAX TO ZERO
  *                  COPIES TIME INTO RESETAT, LASTTIME
  *
  *     UPDATE(V)    ADDS 1 TO OBS
  *                  ADDS V*SPAN TO SUMT
  *                  ADDS V*V*SPAN TO SUMSQT
  *                  MIN BECOMES MINIMUM(MIN, V)
  *                  MAX BECOMES MAXIMUM(MAX, V)
  *                  COPIES TIME INTO LASTTIME
  *
  *     REPORT       PRINTS ON ONE LINE:
  *                  TITLE/RESET/OBS/MEAN/EST.ST.DEV./MIN/MAX
  *;

  REAL SUMT, SUMSQT, MIN, MAX, LASTTIME, LASTV;

  PROCEDURE REPORT;
  BEGIN REAL SPAN, AVG, T;
  WRITETRN;
  IF OBS = 0 THEN OUTF.OUTTEXT(MINUSES.SUB(1, 40)) ELSE
  BEGIN T := TIME;
  SPAN := T - RESETAT;  T := T - LASTTIME;
  IF SPAN<EPSILON THEN OUTF.OUTTEXT(MINUSES.SUB(1,20)) ELSE
  BEGIN AVG := (SUMT+LASTV*T)/SPAN;
  PRINTREAL(AVG);
  PRINTREAL(SQRT(ABS((SUMSQT+LASTV**2*T)/SPAN-AVG**2)));
  END;
  PRINTREAL(MIN);
  PRINTREAL(MAX);
  END;
  OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE RESET;
  BEGIN OBS := 0;
  SUMT := SUMSQT := 0.0;
  MIN  := MAX    := 0.0;
  LASTTIME := RESETAT := TIME;
  END***RESET***;

  PROCEDURE UPDATE(V); REAL V;
  BEGIN REAL NOW, SPAN;
  OBS      := OBS + 1;
  NOW      := TIME;
  SPAN     := NOW - LASTTIME;
  LASTTIME := NOW;
  SUMT     := SUMT + LASTV*SPAN;
  SUMSQT   := SUMSQT + LASTV**2*SPAN;
  LASTV    := V;
  IF OBS = 1 THEN MIN := MAX := V ELSE
     IF V < MIN THEN MIN := V ELSE
     IF V > MAX THEN MAX := V;
  END*** UPDATE ***;

  JOIN(ACCUMQ);
  END***ACCUMULATE***;

  COMMENT-------------------- H I S T O G R A M ---------------;

  TAB CLASS HISTOGRAM(LOWER, UPPER, NCELLS); REAL LOWER, UPPER;
                                             INTEGER NCELLS;
  BEGIN                   COMMENT
  *
  * VARIABLES:
  *
  *    .TITLE        USER SUPPLIED DESCRIPTIVE TEXT (PARAM.)
  *    .N            NUMBER OF INCIDENCES
  *    .RESETAT      LAST TIME OF SETTING OR TIME OF CREATION
  *    .NEXT         REF TO NEXT TAB IN REPORTQ
  *     LOWER        LOWER LIMIT OF THE VARIABLE RANGE
  *     UPPER        UPPER LIMIT OF THE VARIABLE RANGE
  *     NCELLS       NUMBER OF CELLS IN THIS RANGE
  *     WIDTH        CELL WIDTH (= (UPPER - LOWER)/NCELLS)
  *     TABLE        ARRAY TO HOLD THE INCIDENCES. VALUES IN
  *                  RANGE GO IN CELLS 1, 2, .... , N.
  *                  UNDERFLOW VALUES GO IN CELL 0.
  *                  OVERFLOW VALUES IN CELL LIMIT=NCELLS+1
  *     LIMIT        NCELLS + 1.
  *     MYT          TO ACCUMULATE SUM , SUMSQ OF READINGS
  *
  * PROCEDURES:
  *     RESET        SETS OBS TO ZERO
  *                  COPIES TIME INTO RESETAT
  *                  RESETS MYT
  *
  *     UPDATE(V)    ADDS 1 TO OBS
  *                  ADDS 1 TO THE APPROPRIATE TABLE CELL
  *                  CALLS MYT.UPDATE(V)
  *
  *     REPORT       DRAWS A PICTURE OF THE HISTOGRAM.
  *                  CALLS MYT.REPORT
  *;

  INTEGER ARRAY TABLE(0 : NCELLS + 1);
  REF(NOTALLY)MYT;
  INTEGER LIMIT;
  REAL WIDTH;

  PROCEDURE REPORT;
  BEGIN TEXT T;
  INTEGER I, NEXT, A, OCC;
  REAL R, F, SCALE, SUM, FREQ;

  INTEGER PROCEDURE MAXIMUMELEMENT;
  BEGIN INTEGER K, J;
  IF OBS > 0 THEN
  BEGIN K := TABLE(0);
  FOR  J := 1 STEP 1 UNTIL LIMIT DO
    IF TABLE(J) > K THEN K := TABLE(J);
  MAXIMUMELEMENT := K;
  END;
  END*** MAXIMUM ELEMENT ***;

  A   := 40;
  OUTF.SETPOS(29);
  OUTF.OUTTEXT("S U M M A R Y");
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  OUTF.OUTTEXT(HEADINGRTN);
  OUTF.OUTTEXT(TALLYHEADING);
  OUTF.OUTIMAGE;
  MYT.REPORT;
  OUTF.OUTIMAGE;
  IF OBS = 0 THEN
  BEGIN
  OUTF.SETPOS(21);
  OUTF.OUTTEXT("***NO ENTRIES RECORDED***");
  END ELSE
  BEGIN SCALE  := 30 / MAXIMUMELEMENT;
  OUTF.OUTTEXT("CELL/LOWER LIM/    N/   FREQ/  CUM %");
  OUTF.OUTIMAGE;
  OUTF.SETPOS(A);  OUTF.OUTCHAR('I');
  OUTF.OUTTEXT(MINUSES.SUB(1, 30));  OUTF.OUTIMAGE;
  F     := 1/OBS;
  R     := LOWER - WIDTH;
  FOR I := 0 STEP 1 UNTIL LIMIT DO
  BEGIN OUTF.OUTINT(I, 4);
  IF I = 0 THEN OUTF.OUTTEXT(" -INFINITY")
           ELSE PRINTREAL(R);
  NEXT := TABLE(I);          OUTF.OUTINT(NEXT, 6);
  FREQ := NEXT*F;            OUTF.OUTFIX(FREQ, 2, 8);
  SUM  := SUM + FREQ*100.0;  OUTF.OUTFIX(SUM , 2, 8);
  OUTF.SETPOS(A);  OUTF.OUTCHAR('I');
  IF NEXT > 0 THEN
  BEGIN T :- STARS.SUB(1, SCALE*NEXT);
  IF T == NOTEXT THEN OUTF.OUTCHAR('.')
                 ELSE OUTF.OUTTEXT(T);
  END;
  OUTF.OUTIMAGE;
  ANYMORETOPRINT:
  OCC  := OCC+NEXT;
  IF OCC = OBS AND I+3 < LIMIT THEN
  BEGIN
  OUTF.OUTIMAGE;
  OUTF.SETPOS(A+6);
  OUTF.OUTTEXT("**REST OF TABLE EMPTY**");
  OUTF.OUTIMAGE;
  OUTF.OUTIMAGE;
  GOTO FINISH;
  END;
  R := R + WIDTH;
  END;
  FINISH:
  OUTF.SETPOS(A);  OUTF.OUTCHAR('I');
  OUTF.OUTTEXT(MINUSES.SUB(1, 30));  OUTF.OUTIMAGE;
  END;
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE RESET;
  BEGIN INTEGER K;
  OBS := 0;
  FOR K := 0 STEP 1 UNTIL LIMIT DO
    TABLE(K) := 0;
  RESETAT := TIME;
  IF MYT =/= NONE THEN MYT.RESET;
  END***RESET***;

  PROCEDURE UPDATE(V); REAL V;
  BEGIN INTEGER CELL;
  OBS   := OBS + 1;
  MYT.UPDATE(V);
  V     := V - LOWER;
  IF V < 0.0 THEN CELL := 0 ELSE
  BEGIN CELL  := ENTIER(V/WIDTH) + 1;
  IF CELL > LIMIT THEN CELL := LIMIT;
  END;
  TABLE(CELL) := TABLE(CELL) + 1;
  END*** UPDATE ***;

  IF UPPER <= LOWER OR NCELLS < 1 THEN
  BEGIN
  ERROR(19, NONE, THIS TAB, 0, "NEW HISTOGRAM(T,L,U,N);");
  IF NCELLS < 1 THEN NCELLS := 10;
  IF LOWER >= UPPER THEN
  BEGIN
  LOWER := 0.0;
  UPPER := 100.0;
  END;
  END;
  WIDTH := (UPPER - LOWER)/NCELLS ;
  LIMIT := NCELLS + 1;
  MYT   :- NEW NOTALLY(TITLE);
  JOIN(HISTOQ);
  END***HISTOGRAM***;

  COMMENT----------R E G R E S S I O N S-------------;

  TAB CLASS REGRESSION(TITLE2); VALUE TITLE2; TEXT TITLE2;
  BEGIN
  REAL X, Y, XX, XY, YY;

  PROCEDURE UPDATE(VX, VY); REAL VX, VY;
  BEGIN
  OBS := OBS + 1;
  X   := X + VX;
  Y   := Y + VY;
  XX  := VX**2 + XX;
  XY  := VX*VY + XY;
  YY  := VY**2 + YY;
  END***UPDATE***;

  PROCEDURE RESET;
  BEGIN
  OBS := 0;
  RESETAT := TIME;
  X := Y := XX := XY := YY := 0.0;
  END***RESETAT***;

  PROCEDURE REPORT;
  BEGIN
  REAL DX, DY, A0, A1, SD, R2;

  OUTF.SETPOS((52-TITLE.LENGTH-TITLE2.LENGTH)//2);
  OUTF.OUTTEXT("REGRESSION OF '");
  OUTF.OUTTEXT(TITLE2);
  OUTF.OUTTEXT("' UPON '");
  OUTF.OUTTEXT(TITLE);
  OUTF.OUTCHAR(''');
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  OUTF.SETPOS(17);
  OUTF.OUTTEXT("   (RE)SET/    OBS/     XBAR/     YBAR");
  OUTF.OUTIMAGE;
  OUTF.SETPOS(17);
  PRINTREAL(RESETAT);
  OUTF.OUTINT(OBS, 8);
  IF OBS > 0 THEN
  BEGIN
  PRINTREAL(X/OBS);
  PRINTREAL(Y/OBS);
  END;
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  IF OBS <= 5 THEN
  BEGIN
  OUTF.SETPOS(24);
  OUTF.OUTTEXT("*** INSUFFICIENT DATA ***");
  END ELSE
  BEGIN
  DX := ABS(OBS*XX - X**2);
  DY := ABS(OBS*YY - Y**2);
  IF DX < 0.00001 OR DY < 0.00001 THEN
  BEGIN
  OUTF.SETPOS(27);
  OUTF.OUTTEXT("***DEGENERATE DATA***");
  OUTF.OUTIMAGE;
  IF DX < 0.00001 THEN
  BEGIN
  OUTF.SETPOS(25);
  OUTF.OUTTEXT("X = CONSTANT = ");
  PRINTREAL(X/OBS);
  OUTF.OUTIMAGE;
  END;
  IF DY < 0.00001 THEN
  BEGIN
  OUTF.SETPOS(25);
  OUTF.OUTTEXT("Y = CONSTANT = ");
  PRINTREAL(Y/OBS);
  OUTF.OUTIMAGE;
  END;
  END***DEGENERATE CASE***ELSE
  BEGIN
  A1 := (OBS*XY - X*Y)/DX;
  A0 := (Y*XX - X*XY)/DX;
  SD := SQRT((YY - A0*Y - A1*XY)/(OBS-2));
  R2 := (OBS*XY - X*Y)**2/(DX*DY);
  OUTF.OUTTEXT("  RES.ST.DEV/ EST.REG.COEFF/ INTERCEPT/");
  OUTF.OUTTEXT(" ST.DEV.REG.COEFF/ CORR.COEFF");
  OUTF.OUTIMAGE;
  OUTF.SETPOS( 3);  PRINTREAL(SD);
  OUTF.SETPOS(18);  PRINTREAL(A1);
  OUTF.SETPOS(29);  PRINTREAL(A0);
  OUTF.SETPOS(47);  PRINTREAL(OBS*SD/SQRT((OBS-2)*DX));
  OUTF.SETPOS(59);  PRINTREAL(SQRT(R2));
  OUTF.OUTIMAGE;
  END;
  END;
  OUTF.OUTIMAGE;
  OUTF.OUTIMAGE;
  END***REPORT***;

  IF TITLE2.LENGTH > 12 THEN TITLE2 :- TITLE2.SUB(1, 12);
  END***REGRESSION***;

  COMMENT--------------------SEED GENERATOR--------------------
  *
  * THE BASIC RNG IS
  *
  *    U(K+1) <- U(K) * 2**13 MODULO 67099547
  *
  * (SEE !NEXT PAGE: ZYQSAMPLE IN DIST)
  * THIS RNG WAS DEVELOPED AND TESTED BY DOWNHAM AND ROBERTS
  * BY NOTING THAT
  *
  *    U(K+120633) <- U(K) * 36855 MODULO 67099547
  *
  * WE GET OUR ROUTINE FOR GENERATING WELL SEPARATED SEEDS
  *
  * U(0) <- 907, U(1) <- 33427485, U(2) <- 22276755, ...
  *
  * YOU MAY CHANGE THE DEFAULTS BY ASSIGNING A FRESH VALUE
  * TO ZYQSEED.
  *;

  INTEGER PROCEDURE ZYQNEXTSEED;
  BEGIN INTEGER K;
  FOR K := 7, 13, 15, 27 DO
  BEGIN ZYQSEED := ZYQSEED*K;
  IF ZYQSEED >= ZYQMODULO THEN
    ZYQSEED := ZYQSEED - ZYQSEED//ZYQMODULO*ZYQMODULO;
  END;
  ZYQNEXTSEED := ZYQSEED;
  END***ZYQNEXTSEED***;

  PROCEDURE SETSEED(N); INTEGER N;
  BEGIN
  IF N < 0 THEN N := -N;
  IF N >= ZYQMODULO THEN N := N-N//ZYQMODULO*ZYQMODULO;
  IF N = 0 THEN N := ZYQMODULO//2;
  ZYQSEED := N;
  END***SETSEED***;

  COMMENT-------------D I S T R I B U T I O N S----------------
  *
  * THIS SECTION HAS THE DEFINITIONS OF THE SAMPLING MECHANISMS
  * DEFINED IN DEMOS. THESE DEFINITIONS ARE:
  *
  *                               DIST
  *
  *            RDIST              IDIST                BDIST
  *
  * RDIST =
  * CONSTANT   ERLANG   EMPIRICAL   NEGEXP    NORMAL    UNIFORM
  *
  * IDIST =
  * RANDINT   POISSON
  *
  * BDIST =
  * DRAW
  * CONSTANT         EVERY SAMPLE RETURNS THE SAME VALUE.
  *
  * EMPIRICAL        DEFINES A CUMULATIVE PROBABILITY FUNCTION
  *                  SUPPLIED AS A PAIR OF TABLES BY THE USER.
  *
  * AND THE REST FOLLOW SIMULA'S DRAWING PROCEDURES IN THE
  * OBVIOUS WAY. BY BUILDING AN OBJECT, WE MAKE A DRAWING BY A
  * CALL 'OBJ'.SAMPLE AND NEED NOT PASS OVER ANY PARAMETERS.
  * AND THE OBJECT NAME CAN BE RELEVANT, E.G. ARRIVALS.SAMPLE.
  *;

  TAB CLASS DIST;
  BEGIN INTEGER U, USTART, TYPE;
  BOOLEAN ANTITHETIC;

  REAL PROCEDURE ZYQSAMPLE;
  BEGIN INTEGER K;
  FOR K := 32, 32, 8 DO
  BEGIN U := K*U;
  IF U >= ZYQMODULO THEN U := U - U//ZYQMODULO*ZYQMODULO;
  END;
  ZYQSAMPLE := IF ANTITHETIC THEN 1.0 -  U/ZYQMODULO
                             ELSE U/ZYQMODULO;
  OBS := OBS+1;
  END***ZYQSAMPLE***;

  PROCEDURE SETSEED(N); INTEGER N;
  BEGIN
  IF N < 0 THEN N := -N;
  IF N >= ZYQMODULO THEN N := N-N//ZYQMODULO*ZYQMODULO;
  IF N = 0 THEN N := ZYQMODULO//2;
  U := N;
  END***SETSEED***;

  PROCEDURE ZYQFAIL(T1,T2,X,Y);VALUE T1,T2;TEXT T1,T2;REAL X,Y;
  BEGIN
    SWITCH CASE:=NORMALL, UNIFORML, ERLANGL,
                 RANDINTL, NEGEXPL, POISSONL;
  OUTTEXT("**ERROR IN CREATION OF ");
  OUTTEXT(DISTTYPE(TYPE));
  OUTTEXT("DIST '");
  OUTTEXT(TITLE);
  OUTCHAR(''');  OUTCHAR('.');
  OUTIMAGE;
  OUTTEXT(ZYQREASON); OUTTEXT(T1); OUTIMAGE;
  OUTTEXT(ZYQRECVRY); OUTTEXT(T2);
  GOTO CASE(TYPE);
  GOTO JOIN;
    NORMALL:
    ERLANGL:
    NEGEXPL:
  POISSONL:  OUTREAL(X, 5, 12);
             GOTO JOIN;
  UNIFORML:  OUTREAL(X, 5, 12);
             OUTTEXT(", B =");
             OUTREAL(Y, 5, 12);
             GOTO JOIN;
  RANDINTL:  OUTINT(THIS DIST QUA RANDINT.A, 10);
             OUTTEXT(", B =");
             OUTINT(THIS DIST QUA RANDINT.B, 10);
  JOIN:      OUTCHAR('.'); OUTIMAGE; OUTIMAGE;
  END***ZYQFAIL***;

  PROCEDURE REPORT;
  BEGIN SWITCH CASE := NORMALL, UNIFORML, ERLANGL, RANDINTL,
                     NEGEXPL, POISSONL, DRAWL,  CONSTANTL;
  WRITETRN;
  OUTF.OUTCHAR(' ');
  OUTF.OUTTEXT(DISTTYPE(TYPE));
  OUTF.SETPOS(41);
  GOTO CASE(TYPE);
  GOTO SKIPALL;
  NORMALL:    PRINTREAL(THIS DIST QUA NORMAL.A);
              PRINTREAL(THIS DIST QUA NORMAL.B);
              GOTO EXIT;
  UNIFORML:   PRINTREAL(THIS DIST QUA UNIFORM.A);
              PRINTREAL(THIS DIST QUA UNIFORM.B);
              GOTO EXIT;
  ERLANGL:    PRINTREAL(THIS DIST QUA ERLANG.A);
              OUTF.OUTINT(THIS DIST QUA ERLANG.B, 10);
              GOTO EXIT;
  RANDINTL:   OUTF.OUTINT(THIS DIST QUA RANDINT.A, 10);
              OUTF.OUTINT(THIS DIST QUA RANDINT.B, 10);
              GOTO EXIT;
  NEGEXPL:    PRINTREAL(THIS DIST QUA NEGEXP.A);
              GOTO SKIP;
  POISSONL:   PRINTREAL(THIS DIST QUA POISSON.A);
              GOTO SKIP;
  DRAWL:      PRINTREAL(THIS DIST QUA DRAW.A);
              GOTO SKIP;
  CONSTANTL:  PRINTREAL(THIS DIST QUA CONSTANT.A);
              GOTO SKIPALL;
  SKIP:       OUTF.SETPOS(61);
  EXIT:       OUTF.OUTINT(USTART, 10);
  SKIPALL:    OUTF.OUTIMAGE;
  END***REPORT***;

  U := USTART := ZYQNEXTSEED;
  IF THIS DIST IN EMPIRICAL THEN JOIN(EMPQ)
                            ELSE JOIN(DISTQ);
  END***DIST***;

  COMMENT--------------------R   D I S T S--------------------;


  DIST CLASS RDIST; VIRTUAL: REAL PROCEDURE SAMPLE;;

  RDIST CLASS CONSTANT(A); REAL A;
  BEGIN
  REAL PROCEDURE SAMPLE;
  BEGIN OBS := OBS + 1;
  SAMPLE := A;
  END***SAMPLE***;

  TYPE := 8;
  END***CONSTANT***;


  RDIST CLASS NORMAL(A, B); REAL A, B;
  BEGIN REAL ZYQU, ZYQV; BOOLEAN ZYQEVEN;

  REAL PROCEDURE SAMPLE;
  BEGIN REAL Z;
  IF ZYQEVEN THEN
  BEGIN ZYQEVEN := FALSE;
  Z    := ZYQU*COS(ZYQV);
  OBS  := OBS + 1;
  END ELSE
  BEGIN ZYQEVEN := TRUE;
  ZYQU := SQRT(-2.0*LN(ZYQSAMPLE));
  ZYQV := 6.28318530717959*ZYQSAMPLE;
  Z    := ZYQU*SIN(ZYQV);
  OBS  := OBS - 1;
  END;
  SAMPLE := Z*B+A;
  END***SAMPLE***;

  TYPE := 1;
  IF B < 0.0 THEN
  BEGIN B := -B;
  ZYQFAIL("ST. DEV. 'B' < 0.0.",
          "ABSOLUTE VALUE ~B~ TAKEN. B IS NOW", B, 0.0);
  END;
  END***NORMAL***;


  RDIST CLASS NEGEXP(A); REAL A;
  BEGIN
  REAL PROCEDURE SAMPLE;
  BEGIN
  SAMPLE := -LN(ZYQSAMPLE)/A;
  END***SAMPLE***;

  TYPE := 5;
  IF A <= 0.0 THEN
  BEGIN A := IF A < 0.0 THEN -A ELSE 0.001;
  ZYQFAIL("NON-POSITIVE VALUE FOR 'A' (=ARRIVAL RATE).",
          "A RESET TO", A, 0.0);
  END;
  END***NEGEXP***;


  RDIST CLASS UNIFORM(A, B); REAL A, B;
  BEGIN REAL ZYQSPAN;
  REAL PROCEDURE SAMPLE;
  BEGIN
  SAMPLE := ZYQSPAN*ZYQSAMPLE + A;
  END***SAMPLE***;

  TYPE := 2;
  IF A > B THEN
  BEGIN REAL Q;
  Q := A; A := B; B := Q;
  ZYQFAIL("LOWER BOUND 'A' > UPPER BOUND 'B'.",
          "BOUNDS SWAPPED. NOW, A =", A, B);
  END;
  ZYQSPAN := B-A;
  END***UNIFORM***;


  RDIST CLASS ERLANG(A, B); REAL A;  INTEGER B;
  BEGIN REAL ZYQAB;
  REAL PROCEDURE SAMPLE;
  BEGIN INTEGER K, M; REAL PROD;
  M := OBS;
  PROD := ZYQSAMPLE;
  FOR K := 2 STEP 1 UNTIL B DO
    PROD := PROD * ZYQSAMPLE;
  OBS := M+1;
  SAMPLE := -LN(PROD)*ZYQAB;
  END***SAMPLE***;

  TYPE := 3;
  IF A <= 0.0 THEN
  BEGIN A := IF A < 0.0 THEN -A ELSE 0.01;
  ZYQFAIL("'A' (=1/MEAN) <= 0.0.",
          "A RESET TO", A, 0.0);
  END;
  IF B < 0.0 THEN
  BEGIN B := IF B < 0 THEN -B ELSE 1;
  ZYQFAIL("'B' (ERLANG ST. DEV.) <= 0.0.",
          "B RESET TO", B, 0.0);
  END;
  ZYQAB := A/B;
  END***ERLANG***;

  RDIST CLASS EMPIRICAL(SIZE); INTEGER SIZE;
  BEGIN REAL ARRAY X, P(1 : SIZE);

  REAL PROCEDURE SAMPLE;
  BEGIN REAL Q;  INTEGER K;
  Q := ZYQSAMPLE;
  K := 2;
  WHILE P(K) < Q DO
    K := K + 1;
  SAMPLE := X(K-1) + (X(K)-X(K-1))*(Q-P(K-1))/(P(K)-P(K-1));
  END***SAMPLE***;

  PROCEDURE REPORT;
  BEGIN INTEGER K;
  OUTF.SETPOS(16);
  OUTF.OUTTEXT(HEADINGRTN); OUTF.OUTTEXT("/     SEED");
  OUTF.OUTIMAGE;
  OUTF.SETPOS(16);
  WRITETRN;
  OUTF.OUTINT(USTART, 10);
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  OUTF.SETPOS(16);
  OUTF.OUTTEXT("       K/  DIST. X(K)/  PROB. P(K)");
  OUTF.OUTIMAGE;
  FOR K := 1 STEP 1 UNTIL SIZE DO
  BEGIN
  OUTF.SETPOS(16);
  OUTF.OUTINT(K, 8);
  OUTF.OUTFIX(X(K), 5, 13);
  OUTF.OUTFIX(P(K), 5, 13);
  OUTF.OUTIMAGE;
  END;
  OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE READ;
  BEGIN BOOLEAN GOOD, FIRST; INTEGER K, L;
  REAL A, B;

  PROCEDURE Z(W, R, F, C); VALUE W, C; TEXT W, C;
                               REAL R; BOOLEAN F;
  BEGIN
  IF GOOD THEN
  BEGIN GOOD := FALSE;
  SYSOUT.SETPOS(11);
  OUTTEXT("**READ FAULT(S) IN EMPIRICAL '");
  OUTTEXT(TITLE);
  OUTCHAR(''');  OUTCHAR('.');
  OUTIMAGE;
  END;
  IF FIRST THEN
  BEGIN FIRST := FALSE;
  OUTIMAGE;
  OUTTEXT("**INPUTS   : K ="); OUTINT(K, 4);
  OUTTEXT(", DIST(K) =");      OUTFIX(A, 3, 10);
  OUTTEXT(", PROB(K) =");      OUTFIX(B, 3, 10);
  OUTIMAGE;
  OUTTEXT(ZYQRECVRY);
  END;
  SYSOUT.SETPOS(14);
  OUTTEXT(W);
  IF F THEN OUTFIX(R, 6, 10) ELSE OUTFIX(R, 3, 10);
  OUTTEXT(C); OUTCHAR('.');
  OUTIMAGE;
  END***Z - THE WARNING ROUTINE***;

  K := 1;
  GOOD := FIRST := TRUE;
  X(1) := A := INF.INREAL; B := INF.INREAL;
  IF ABS(B) > EPSILON THEN
    Z("P(1) IS NOT ZERO. P(1) =>",0.0,TRUE," (FIRST PROB)");
  FOR K := 2 STEP 1 UNTIL SIZE DO
  BEGIN FIRST := TRUE;
  X(K) := A := INF.INREAL; P(K) := B := INF.INREAL;
  IF A < X(K-1) THEN
  BEGIN X(K) := X(K-1);
  Z("X(K) < X(K-1). X(K) =>",X(K),FALSE," (=X(K-1))");
  END;
  IF B < 0.0 OR B < P(K-1) OR B > 1.0 THEN
  BEGIN P(K) := P(K-1)+0.001;
  IF P(K) > 1.0 THEN P(K) := 1.0;
  Z("ILLEGAL PROB. P(K) =>",P(K),TRUE," (=P(K-1)+)");
  END;
  END;
  IF ABS(P(SIZE)-1.0) > EPSILON THEN
   Z("P(SIZE) NE 1.0. P(SIZE) =>", 1.0, TRUE, " (LAST PROB.)");
  P(SIZE) := 1.0;
  IF NOT GOOD THEN
  BEGIN OUTTEXT(MINUSES.SUB(1, 62));
  OUTIMAGE; OUTIMAGE;
  END;
  END***READ***;

  TYPE := 9;
  IF SIZE = 1 THEN ERROR(20, NONE, THIS EMPIRICAL, 0,
      "NEW EMPIRICAL(T, SIZE); TEXT T; INTEGER SIZE;");
  READ;
  END***EMPIRICAL***;

  COMMENT--------------------I   D I S T S--------------------;

  DIST CLASS IDIST; VIRTUAL: INTEGER PROCEDURE SAMPLE;;

  IDIST CLASS RANDINT(A, B); INTEGER A, B;
  BEGIN REAL ZYQSPAN;
  INTEGER PROCEDURE SAMPLE;
  BEGIN
  SAMPLE := ENTIER(ZYQSPAN*ZYQSAMPLE) + A;
  END***SAMPLE***;

  TYPE := 4;
  IF A > B THEN
  BEGIN INTEGER Q;
  Q := A; A := B; B := Q;
  ZYQFAIL("LOWER BOUND 'A' > UPPER BOUND 'B'.",
          "BOUNDS SWAPPED. NOW A =", A, B);
  END;
  ZYQSPAN := B-A+1;
  END***RANDINT***;

  IDIST CLASS POISSON(A); REAL A;
  BEGIN
  INTEGER PROCEDURE SAMPLE;
  BEGIN INTEGER M; REAL P, Q;
  P := EXP(-A);
  Q := 1.0;
  L: Q := Q*ZYQSAMPLE;
  IF Q >= P THEN
  BEGIN
  M := M + 1;
  GOTO L;
  END;
  SAMPLE := M;
  OBS := OBS - M;
  END***SAMPLE***;

  TYPE := 6;
  IF A <= 0.0 THEN
  BEGIN A := IF A < 0.0 THEN -A ELSE 0.001;
  ZYQFAIL("NON-POSITIVE VALUE FOR 'A' (=MEAN).",
          "A RESET TO", A, 0.0);
  END;
  END***POISSON***;

  COMMENT--------------------B   D I S T S--------------------;

  DIST CLASS BDIST; VIRTUAL: BOOLEAN PROCEDURE SAMPLE;;

  BDIST CLASS DRAW(A); REAL A;
  BEGIN
  BOOLEAN PROCEDURE SAMPLE;
  BEGIN
  SAMPLE := A > ZYQSAMPLE;
  END***SAMPLE***;

  TYPE := 7;
  END***DRAW***;

  COMMENT-------------READDIST-----------------------------------;

  PROCEDURE READDIST(D, TITLE); NAME D; VALUE TITLE;
                             REF(DIST)D; TEXT TITLE;
  BEGIN TEXT F, REST;
  INTEGER P, IMLENGTH1, L, K, T;

  PROCEDURE FAIL(D, EOF); BOOLEAN D, EOF;
  BEGIN OUTTEXT("**ERROR IN READING DIST WITH TITLE = '");
  OUTTEXT(TITLE);
  OUTCHAR(''');  OUTCHAR('.');
  OUTIMAGE;
  OUTTEXT("**NO MATCH FOUND WHEN SCANNING INPUT FILE FOR ");
  IF D THEN OUTTEXT(" DIST TYPE") ELSE OUTTEXT("TITLE");
  OUTCHAR('.');
  OUTIMAGE;
  OUTTEXT(ZYQREASON);
  IF EOF THEN OUTTEXT("END OF INPUT FILE MARKER HIT.") ELSE
  BEGIN OUTTEXT("REST OF CURRENT INPUT IMAGE READS:");
  OUTIMAGE;
  OUTTEXT(REST);
  END;
  ABORT(TRUE);
  END***FAIL***;

  COMMENT***CHECKTITLE***;
  IMLENGTH1 := INF.IMAGE.LENGTH + 1;
  IF INF.LASTITEM THEN FAIL(FALSE, TRUE);
  L := TITLE.LENGTH;
  P := INF.IMAGE.POS;
  REST :- INF.IMAGE.SUB(P, IMLENGTH1 - P);
  IF REST.LENGTH >= L THEN F :- REST.SUB(1, L);
  IF F NE TITLE THEN FAIL(FALSE,FALSE);
  INF.SETPOS(P + L);

  COMMENT***GET DIST TYPE***;
  IF INF.LASTITEM THEN FAIL(TRUE, TRUE);
  P    := INF.IMAGE.POS;
  REST :- INF.IMAGE.SUB(P, IMLENGTH1 - P);
  L    := REST.LENGTH;
  FOR K := 6, 7, 6, 7, 6, 7, 4, 8, 9 DO
  BEGIN T := T + 1;
  IF K <= L THEN
  BEGIN
  IF DISTTYPE(T) = REST.SUB(1, K) THEN GOTO FOUND;
  END;
  END;
  FAIL(TRUE, FALSE);
  FOUND: INF.SETPOS(P + K);
  IF T=1 THEN D:-NEW NORMAL(TITLE,INF.INREAL,INF.INREAL) ELSE
  IF T=2 THEN D:-NEW UNIFORM(TITLE,INF.INREAL,INF.INREAL)ELSE
  IF T=3 THEN D:-NEW ERLANG(TITLE,INF.INREAL,INF.ININT)  ELSE
  IF T=4 THEN D:-NEW RANDINT(TITLE,INF.ININT,INF.ININT)  ELSE
  IF T=5 THEN D:-NEW NEGEXP(TITLE,INF.INREAL)            ELSE
  IF T=6 THEN D:-NEW POISSON(TITLE,INF.INREAL)           ELSE
  IF T=7 THEN D:-NEW DRAW(TITLE,INF.INREAL)              ELSE
  IF T=8 THEN D:-NEW CONSTANT(TITLE,INF.INREAL)          ELSE
  IF T=9 THEN D:-NEW EMPIRICAL(TITLE, INF.ININT);
  END***READDIST***;

  COMMENT-------------------- REPORTQ -------------------------;

  CLASS REPORTQ(H, L1, L2); VALUE H; TEXT H, L1, L2;
  BEGIN                COMMENT
  *
  * EVERY CREATED TAB IS PUT INTO A REPORTQ IN THE ORDER
  * OF ITS CREATIONS. FROM THERE THEY CAN ALL BE REPORTED
  * TOGETHER ON A CALL 'REPORT' , OR ALL RESET TO THE NULL
  * STATE BY A CALL 'RESET'.
  *
  * VARIABLES :
  *     FIRST    REF TO FIRST TAB IN REPORTQ
  *     LAST     REF TO LAST TAB IN REPORTQ
  *
  * PROCEDURES:
  *     RESET    RESETS EACH AND EVERY REPRESENTED TAB
  *
  *     REPORT   REPORTS EACH AND EVERY TAB AS ABOVE
  *;

  REF(TAB)FIRST, LAST;

  PROCEDURE REPORT;
  BEGIN REF(TAB)T;
  INTEGER P, L;
  L := H.LENGTH;   P := (72-L)//2;
  OUTF.SETPOS(P);  OUTF.OUTTEXT(H);
  OUTF.OUTIMAGE;
  OUTF.SETPOS(P);  OUTF.OUTTEXT(STARS.SUB(1, L));
  OUTF.OUTIMAGE;   OUTF.OUTIMAGE;
  IF L1 =/= NOTEXT THEN
  BEGIN
  OUTF.OUTTEXT(L1);
  IF L2 =/= NOTEXT THEN OUTF.OUTTEXT(L2);
  OUTF.OUTIMAGE;
  END;
  T :- FIRST;
  WHILE T =/= NONE DO
  BEGIN T.REPORT;
  T :- T.NEXT;
  END;
  END***REPORT***;

  PROCEDURE RESET;
  BEGIN REF(TAB)T;
  T :- FIRST;
  WHILE T =/= NONE DO
  BEGIN T.RESET;
  T :- T.NEXT;
  END;
  END***RESET***;

  END***REPORTQ***;

  COMMENT-------------------- REPORTING AIDS -----------------;

  PROCEDURE CLOCKTIME;
  BEGIN OUTF.SETPOS(24);
  OUTF.OUTTEXT("CLOCK TIME = ");
  PRINTREAL(TIME);
  OUTF.OUTIMAGE;
  END***CLOCK TIME***;


  PROCEDURE BOX(T); VALUE T; TEXT T;
  BEGIN
  OUTF.OUTTEXT(STARS);  OUTF.OUTIMAGE;
  OUTF.OUTCHAR('*');    OUTF.SETPOS(70);
  OUTF.OUTCHAR('*');    OUTF.OUTIMAGE;
  OUTF.OUTCHAR('*');
  OUTF.SETPOS((72 - T.LENGTH)//2);
  OUTF.OUTTEXT(T);
  OUTF.SETPOS(70);
  OUTF.OUTCHAR('*');
  OUTF.OUTIMAGE;
  OUTF.OUTCHAR('*');    OUTF.SETPOS(70);
  OUTF.OUTCHAR('*');    OUTF.OUTIMAGE;
  OUTF.OUTTEXT(STARS);  OUTF.OUTIMAGE;
  OUTF.OUTIMAGE;
  END***BOX***;


  TEXT PROCEDURE EDIT(T, K); VALUE T; TEXT T; INTEGER K;
  BEGIN TEXT S;
  T :- T.STRIP;
  IF T.LENGTH > 10 THEN T :- T.SUB(1, 10);
  EDIT :- S :- BLANKS(T.LENGTH + 2);
  S := T;
  IF K < 0 THEN K := -K;
  IF K > 99 THEN K := K - K//100*100;
  S.SUB(S.LENGTH-1, 2).PUTINT(K);
  END***EDIT***;


  PROCEDURE PRINTREAL(X); REAL X;
  BEGIN
  IF X > 0.0 THEN
  BEGIN
  IF X > 99999.999 OR X < 0.1 THEN OUTF.OUTREAL(X, 4, 10)
                              ELSE OUTF.OUTFIX (X, 3, 10);
  END ELSE
  IF X = 0.0 THEN OUTF.OUTFIX(X, 3, 10) ELSE
  BEGIN
  IF X < -9999.999 OR X > -0.1 THEN OUTF.OUTREAL(X, 3, 10)
                               ELSE OUTF.OUTFIX (X, 3, 10);
  END;
  END***PRINTREAL***;

  COMMENT----------E N T I T Y-------------------------;

  CLASS ENTITY(TITLE); VALUE TITLE; TEXT TITLE;
                           VIRTUAL: LABEL LOOP;
  BEGIN REAL TIMEIN, EVTIME;
  INTEGER PRIORITY, CYCLE, WANTS, INTERRUPTED;
  REF(QUEUE)CURRENTQ;
  REF(ENTITY)OWNER;
  BOOLEAN TERMINATED;
  REF(ENTITY)LL, BL, RL;
  REF(ENTITY)SUC, PRED;

  BOOLEAN PROCEDURE AVAIL;
    AVAIL := OWNER == NONE;

  BOOLEAN PROCEDURE IDLE;
    IDLE := EVTIME < 0.0;

  PROCEDURE COOPT;
  BEGIN
  IF OWNER =/= NONE THEN ERROR(1, THIS ENTITY, NONE, 0,
                               "E.COOPT; REF(ENTITY)E;");
  OWNER :- CURRENT;
  IF ZYQTRACE > 0 THEN
    NOTE(1,"COOPTS",THIS ENTITY,CURRENTQ,0.0,0);
  IF CURRENTQ =/= NONE THEN OUT;
  END***COOPT***;

  PROCEDURE INTERRUPT(N); INTEGER N;
  BEGIN
  INTERRUPTED := N;
  IF ZYQTRACE > 0 THEN
    NOTE(24,"INTERRUPTS",THIS ENTITY,NONE,0.0,N);
  IF CURRENT =/= THIS ENTITY THEN
  BEGIN
  IF CURRENTQ =/= NONE THEN OUT;
  IF EVTIME >= 0.0 THEN CANCEL;
  INSERTDELAY0;
  END;
  END***INTERRUPT***;

  PROCEDURE REPEAT;
  BEGIN CYCLE := CYCLE+1;
  GOTO LOOP;
  END***REPEAT***;

  PROCEDURE INTO(Q); REF(QUEUE)Q;
  BEGIN REF(ENTITY)E;
  IF CURRENTQ =/= NONE THEN
  BEGIN
  ERROR(3, THIS ENTITY, CURRENTQ, 0, "E.INTO(Q); REF(QUEUE)Q;");
  OUT;
  END;
  CURRENTQ :- Q;
  TIMEIN   := TIME;
  INSPECT CURRENTQ DO
  BEGIN QINT  := QINT + (TIMEIN-LASTQTIME)*LENGTH;
  LASTQTIME := TIMEIN;
  LENGTH    := LENGTH+1;
  IF LENGTH > MAXLENGTH THEN MAXLENGTH := LENGTH;
  E :- LAST;
  IF E == NONE THEN FIRST :- LAST :- THIS ENTITY ELSE
  IF E.PRIORITY >= PRIORITY THEN
  BEGIN
  PRED :- LAST;
  LAST :- LAST.SUC :- THIS ENTITY;
  END ELSE
  BEGIN
  E :- FIRST;
  WHILE E.PRIORITY >= PRIORITY DO
    E :- E.SUC;
  SUC :- E;
  PRED :- E.PRED;
  IF PRED == NONE THEN FIRST    :- THIS ENTITY
                  ELSE PRED.SUC :- THIS ENTITY;
  SUC.PRED :- THIS ENTITY;
  END;
  END OTHERWISE ERROR(2, THIS ENTITY, NONE, 0,
                      "E.INTO(Q); REF(QUEUE)Q;");
  END***INTO***;

  PROCEDURE OUT;
  BEGIN REAL T;
  T := TIME;
  INSPECT CURRENTQ DO
  BEGIN QINT  := QINT + (T-LASTQTIME)*LENGTH;
  LENGTH    := LENGTH-1;
  LASTQTIME := T;
  OBS       := OBS+1;
  T         := LASTQTIME-TIMEIN;
  IF T < EPSILON THEN ZEROS := ZEROS+1;
  CUM := CUM+T;
  IF SUC == NONE THEN LAST :- PRED ELSE SUC.PRED :- PRED;
  IF PRED == NONE THEN FIRST :- SUC ELSE PRED.SUC :- SUC;
  SUC :- PRED :- NONE;
  END;
  CURRENTQ :- NONE;
  END***OUT***;

  PROCEDURE GETSERIALNO;
  BEGIN REF(ZYQENTTITLE)Z;
  Z :- ZYQENTNAMES;
  WHILE (IF Z == NONE THEN FALSE ELSE TITLE NE Z.T) DO
    Z :- Z.NEXTTITLE;
  IF Z == NONE THEN Z :- NEW ZYQENTTITLE(TITLE);
  TITLE :- BLANKS(Z.L+2);
  TITLE := Z.T;
  TITLE.SUB(Z.L+1, 2).PUTINT(Z.N);
  Z.N := Z.N+1;
  IF Z.N = 100 THEN Z.N := 0;
  END***GET SERIALNO***;

  REF(ENTITY)PROCEDURE NEXTEV;
  BEGIN
  REF(ENTITY)P;
  P :- BL;
  IF P =/= NONE THEN
  BEGIN
  P :- P.RL;
  IF P =/= NONE THEN
  BEGIN
  WHILE P.LL =/= NONE DO
    P :- P.LL;
  END;
  NEXTEV :- P;
  END;
  END***NEXTEV***;

  PROCEDURE LIST;
  BEGIN
  REF(ENTITY)R;
  INTEGER N;
  OUTF.SETPOS(6);
  PRINTREAL(EVTIME);
  OUTF.OUTCHAR(' ');
  OUTF.OUTTEXT(TITLE);
  N := 30;
  FOR R :- LL, BL, RL DO
  BEGIN
  OUTF.SETPOS(N);
  IF R =/= NONE THEN OUTF.OUTTEXT(R.TITLE);
  N := N + 13;
  END;
  OUTF.OUTIMAGE;
  END***LIST***;

  PROCEDURE INSERT;
  BEGIN
                     COMMENT
  * ASSUME:
  *    LL == BL == RL == NONE
  *    EVTIME HAS BEEN SET BY HOLD OR SCHEDULE
  *
  * THIS ROUTINE IS CALLED BY SCHEDULE AND HOLD
  * AND INSERTS O(LOG N) FROM THE TOP.
  *
  *;

  REF(ENTITY)W, X;

  NEWROOT:
  IF EVTIME >= ROOT.EVTIME THEN
  BEGIN
  LL   :- ROOT;
  ROOT :- ROOT.BL :- THIS ENTITY;
  END ELSE

  INSERTBELOWW:
  BEGIN
  W :- ROOT;
  DESCEND:
  X :- W.LL;
  IF X == NONE THEN
  BEGIN
  INSERTASLLOFW:
  W.LL :- THIS ENTITY;
  BL   :- W;
  IF W == CURRENT THEN
  BEGIN
  ERROR(15, THIS ENTITY, NONE, 0,
            "E.INSERT; REF(ENTITY)E;");
  CURRENT :- THIS ENTITY;
  RESUME(CURRENT);
  END;
  END ELSE
  IF EVTIME < X.EVTIME THEN
  INSERT1BELOWX:
  BEGIN
  W :- X;
  GOTO DESCEND;
  END ELSE
  IF EVTIME = X.EVTIME THEN
  INSERTBETWEENXANDW:
  BEGIN
  W.LL :- X.BL :- THIS ENTITY;
  BL   :- W;
  LL   :- X;
  END ELSE
  INSERTINRIGHTSUBTREEOFW:
  BEGIN
  X :- W.RL;
  IF X == NONE THEN
  INSERTASNEWRLOFW:
  BEGIN
  W.RL :- THIS ENTITY;
  BL   :- W;
  END ELSE
  INSERT2BELOWX:
  IF EVTIME < X.EVTIME THEN
  BEGIN
  W :- X;
  GOTO DESCEND;
  END ELSE
  INSERT3BETWEENWANDX:
  BEGIN
  W.RL :- X.BL :- THIS ENTITY;
  BL   :- W;
  LL   :- X;
  END;
  END;
  END;
  END***INSERT***;

  PROCEDURE INSERTAFTERCURRENT;
  BEGIN
                     COMMENT
  * ASSUME:
  *    LL == BL == RL == NONE
  * THIS ROUTINE IS CALLED BY ACQUIRE, RELEASE, ETC
  * AND INSERTS O(1) FROM THE BOTTOM.
  *;

  IF EVTIME < 0.0 THEN
  BEGIN
  LL :- CURRENT;
  EVTIME := CURRENT.EVTIME;
  IF CURRENT==ROOT THEN CURRENT.BL:-ROOT:-THIS ENTITY ELSE
  BEGIN
  BL :- CURRENT.BL;
  CURRENT.BL :- BL.LL :- THIS ENTITY;
  END;
  END;
  END***INSERTAFTERCURRENT***;

  PROCEDURE INSERTDELAY0;
  BEGIN
                     COMMENT
  * ASSUME:
  *    LL == BL == RL == NONE
  * THIS ROUTINE IS CALLED BY ACQUIRE, RELEASE, ETC
  * AND INSERTS O(1) FROM THE BOTTOM.
  *
  *;

  REF(ENTITY)P;
  IF EVTIME < 0.0 THEN
  BEGIN
  EVTIME := CURRENT.EVTIME;
  IF EVTIME >= ROOT.EVTIME THEN
  BEGIN
  LL :- ROOT;
  ROOT :- ROOT.BL :- THIS ENTITY;
  END ELSE
  BEGIN
  P :- CURRENT.BL;
  WHILE EVTIME >= P.EVTIME DO
    P :- P.BL;
  LL :- P.LL;
  BL :- P;
  LL.BL :- BL.LL :- THIS ENTITY;
  END;
  END;
  END***INSERTDELAY0***;

  PROCEDURE SCHEDULE(T); REAL T;
  BEGIN
                     COMMENT
  *
  * A CALL E.SCHEDULE(T) DOES NOTHING IF E
  * IS ALREADY IN THE EVENT LIST(E.EVTIME >= 0.0).
  * OTHERWISE, IT INSERTS E INTO THE EVENT LIST
  * 'DELAY' T. THERE ARE THREE SEPARATE CASES:
  *  T < 0.0, E PREEMPTS CURRENT (0(1) INSERT)
  *  T = 0.0, E FOLLOWS  CURRENT (O(1) INSERT)
  *  T > 0.0, INSERT E FROM THE TOP
  *;

  REF(ENTITY)E;

  IF TERMINATED THEN ERROR(14, THIS ENTITY, NONE, 0,
               "E.SCHEDULE(T); REF(ENTITY)T; REAL T;");
  IF EVTIME < 0.0 THEN
  BEGIN
  IF ZYQTRACE > 0 THEN
    NOTE(2,"SCHEDULES",THIS ENTITY, NONE,T,0);
  OWNER :- NONE;
  IF CURRENTQ =/= NONE THEN OUT;
  PREEMPTCURRENT:
  IF T <= NOW THEN
  BEGIN
  EVTIME     := CURRENT.EVTIME;
  BL         :- CURRENT;
  CURRENT    :- CURRENT.LL :- THIS ENTITY;
  RESUME(CURRENT);
  END ELSE
  INSERTBEHINDCURRENT:
  IF T <= 0.0 THEN INSERTDELAY0 ELSE
  INSERTFROMTHETOP:
  BEGIN
  EVTIME := CURRENT.EVTIME + T;
  INSERT;
  END;
  END ELSE ERROR(16, THIS ENTITY, NONE, 0,
           "E.SCHEDULE(T); REF(ENTITY)E; REAL T;");
  END***SCHEDULE***;

  PROCEDURE CANCEL;
  BEGIN
  COMMENT
  * A CALL E.CANCEL DELETES E FROM THE EVENT LIST.
  * IT HAS NO EFFECT IF E IS PASSIVE (E.EVTIME < 0)
  *;
  REF(ENTITY)P;
  IF EVTIME >= 0.0 THEN
  BEGIN
  IF ZYQTRACE > 0 AND NOT TERMINATED THEN
    NOTE(23,"CANCELS",THIS ENTITY,NONE,0.0,0);
  EVTIME := -1.0;
  IF LL == NONE THEN
  BEGIN
  IF THIS ENTITY == ROOT THEN
    ERROR(13,THIS ENTITY,NONE,0,"E.CANCEL; REF(ENTITY)E;");
  IF THIS ENTITY == CURRENT THEN
  BEGIN
  IF BL.RL == NONE THEN
  BLISNEWCURRENT:
  BEGIN
  CURRENT :- BL;
  CURRENT.LL :- NONE;
  END ELSE
  LEFTMOSTOFSUBTREEOFBLISNEWCURRENT:
  BEGIN
  P :- BL.RL;
  WHILE P.LL =/= NONE DO
  P :- P.LL;
  SWINGRSUBTREETOTHELEFT:
  BL.LL :- BL.RL;
  BL.RL :- NONE;
  CURRENT :- P;
  END;
  BL:- NONE;
  RESUME(CURRENT);
  END ELSE
  LEAFBUTNOTCURRENT:
  BEGIN
  IF BL.LL == THIS ENTITY THEN BL.LL :- RL;
  BL.RL :- NONE;
  BL    :- NONE;
  END;
  END ELSE
  IF RL == NONE THEN COMMENT BUT LL =/= NONE;
  BEGIN
  IF THIS ENTITY == ROOT  THEN ROOT :- LL ELSE
  IF THIS ENTITY == BL.LL THEN BL.LL :- LL
                          ELSE BL.RL :- LL;
  LL.BL :- BL;
  BL :- LL :- NONE;
  END ELSE
  BEGIN COMMENT NEITHER LL NOR RL == NONE;
  P :- RL;
  P.BL :- BL;
  IF THIS ENTITY == ROOT THEN ROOT :- P ELSE
  BEGIN
  IF BL.LL == THIS ENTITY THEN BL.LL :- RL
  ELSE BL.RL :- RL;
  BL :- NONE;
  END;
  WHILE P.LL =/= NONE DO
  P :- P.LL;
  P.LL :- LL;
  LL.BL :- P;
  RL :- LL :- NONE;
  END;
  END ELSE ERROR(17, THIS ENTITY, NONE, 0,
                 "E.CANCEL; REF(ENTITY)E;");
  END***CANCEL***;

  IF TITLE.LENGTH > 10 THEN TITLE :- TITLE.SUB(1, 10);
  GETSERIALNO;
  EVTIME := -1.0;
  DETACH;
  LOOP:;
  INNER;
  TERMINATED := TRUE;
  IF ZYQTRACE>0 THEN NOTE(3,"***TERMINATES",NONE,NONE,0.0,0);
  IF EVTIME >= 0.0 THEN ZYQPASSIVATE;
  END***ENTITY***;

  COMMENT------------H O L D  AND  P A S S I V A T E----------;

  REAL PROCEDURE TIME;
   TIME := CURRENT.EVTIME;


  PROCEDURE ZYQPASSIVATE;
  BEGIN
  REF(ENTITY)P;
  IF CURRENT == ROOT THEN ERROR(15, CURRENT, NONE, 0,
                                     "PASSIVATE;");
  P :- CURRENT.BL;
  CURRENT.BL :- NONE;
  CURRENT.EVTIME := -1.0;
  LOCATENEWCURRENT:
  IF P.RL =/= NONE THEN
  BEGIN
  P.LL :- P.RL;
  P.RL :- NONE;
  WHILE P.LL =/= NONE DO
    P :- P.LL;
  END ELSE P.LL :- NONE;
  CURRENT :- P;
  RESUME(CURRENT);
  END***ZYQPASSIVATE***;


  PROCEDURE PASSIVATE;
  BEGIN
  IF ZYQTRACE>0 THEN NOTE(22,"PASSIVATES",NONE,NONE,0.0,0);
  ZYQPASSIVATE;
  END***PASSIVATE***;


  PROCEDURE HOLD(T); REAL T;
  BEGIN
                     COMMENT
  *
  * DELAYS CURRENT BY T (T >= 0.0).
  * IF T < 0.0, THEN T := 0.0
  *;

  REF(ENTITY)P;

  IF T < 0.0 THEN T := 0.0;
  IF ZYQTRACE>0 THEN NOTE(21,"HOLDS FOR",NONE,NONE,T,0);
  INSPECT CURRENT DO
  BEGIN
  EVTIME := EVTIME+T;
  IF ROOT =/= CURRENT THEN
  MOREWORKTODO:
  BEGIN
  LOCATENEXTEV:
  IF BL.RL == NONE THEN P :- BL ELSE
  BEGIN
  P :- BL.RL;
  WHILE P.LL =/= NONE DO
    P :- P.LL;
  END;
  SKIPIFSTILLCURRENT:
  IF EVTIME >= P.EVTIME THEN
  BEGIN
  BL.LL :- BL.RL;
  BL.RL :- NONE;
  BL :- NONE;
  CURRENT :- P;
  INSERT;
  RESUME(CURRENT);
  END;
  END;
  END;
  END***HOLD***;

  COMMENT----------- Q U E U E ------------------;

  TAB CLASS QUEUE;
  BEGIN
                     COMMENT
  *
  * QUEUE OBJECTS MAY BE USED BY ANYONE AS THEY
  * STAND TO 'SAVE' ENTITIES, BUT THE PRIME USE
  * OF THIS CLASS IS TO SERVE AS PREFIX TO
  *
  *  RES   BIN   WAITQ   CONDQ
  *
  * VARIABLES:
  *    .TITLE        USER SUPPLIED DESCRIPTIVE TEXT
  *    .OBS          NO. OF COMPLETED WAITS IN THIS Q
  *    .RESETAT      TIME OF CREATION, OR LAST RESET
  *    .NEXT         REF TO NEXT TAB IN REPORTQ
  *     LENGTH       CURRENT NO. OF ENTITIES WAITING
  *     ZEROS        NO. OF ZERO (<EPSILON) WAITS
  *     MAXLENGTH    MAXIMUM QLENGTH SINCE RESETAT
  *     QINT         TO RECORD AV. QLENGTH
  *     LASTQTIME    TIME OF LAST INTO/OUT
  *     CUM          TO RECORD AV. WAIT
  *     FIRST        REF TO FIRST ENTITY INQ
  *     LAST         REF TO LAST ENTITY IN Q
  *
  * PROCEDURES:
  *     LIST         PRINTS OUT ENTITIES IN Q,
  *                  RECORDING THEIR
  *                  ORDER, TITLE, PRIORITY, AND
  *                  TIME OF ENTRY
  *
  *     REPORT       PRINTS ON ONE LINE:
  *                  TITLE/RESET/OBS/MAXLENGTH/LENGTH/
  *                  AV.WAIT/ZERO WAITS
  *                  THE AV.WAIT INCLUDES ZEROS
  *                  ZERO WAIT MEANS IN Q FOR < 0.0005
  *
  *     RESET        SETS ZEROS, OBS TO ZERO
  *                  QINT,CUM TO ZERO
  *                  MAXLENGTH TO LENGTH
  *                  LASTQTIME,RESETAT TO TIME
  *;

  INTEGER LENGTH, ZEROS, MAXLENGTH;
  REAL QINT, CUM, LASTQTIME;
  REF(ENTITY)FIRST, LAST;

  PROCEDURE LIST;
  BEGIN
  REF(ENTITY)E;
  INTEGER L, K;
  L := TITLE.LENGTH;
  OUTF.SETPOS((52 - L)//2);
  OUTF.OUTTEXT("ENTITIES WAITING IN ");
  OUTF.OUTTEXT(TITLE);
  OUTF.OUTIMAGE;
  OUTF.SETPOS((52 - L)//2);
  OUTF.OUTTEXT(STARS.SUB(1, 20+L));
  OUTF.OUTIMAGE; OUTF.OUTIMAGE;
  OUTF.SETPOS(19);
  IF LENGTH = 0 THEN
  BEGIN
  OUTF.OUTTEXT("  **** THE QUEUE IS EMPTY. ****");
  OUTF.OUTIMAGE;
  END ELSE
  BEGIN
  OUTF.OUTTEXT("NO OBJECT     PRIORITY ENTRY IN Q");
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  K := 0;
  E :- FIRST;
  WHILE E =/= NONE DO
  BEGIN
  OUTF.SETPOS(17);
  K := K+1;
  OUTF.OUTINT(K, 4);
  OUTF.SETPOS(22);
  OUTF.OUTTEXT(E.TITLE);
  OUTF.SETPOS(33);
  OUTF.OUTINT(E.PRIORITY, 8);
  OUTF.SETPOS(42);
  PRINTREAL(E.TIMEIN);
  OUTF.OUTIMAGE;
  E :- E.SUC;
  END;
  END;
  OUTF.OUTIMAGE;
  OUTF.OUTIMAGE;
  END***LIST***;

  PROCEDURE REPORT;
  BEGIN
  REAL SPAN, T;
  WRITETRN;
  IF (IF THIS QUEUE IN CONDQ
         THEN THIS QUEUE QUA CONDQ.ALL
         ELSE THIS QUEUE IN WAITQ)
    THEN OUTF.IMAGE.SUB(13,1).PUTCHAR('*');
  OUTF.OUTINT(MAXLENGTH, 6);
  OUTF.OUTINT(LENGTH, 6);
  T    := TIME;
  SPAN := T - RESETAT;
  OUTF.SETPOS(44);
  IF SPAN<EPSILON THEN OUTF.OUTTEXT(MINUSES.SUB(1,10)) ELSE
    PRINTREAL((QINT + (T-LASTQTIME)*LENGTH)/SPAN);
  OUTF.OUTINT(ZEROS, 6);
  OUTF.SETPOS(61);
  IF OBS > 0 THEN PRINTREAL(CUM/OBS)
             ELSE OUTF.OUTTEXT(MINUSES.SUB(1,10));
  OUTF.OUTIMAGE;
  IF THIS QUEUE IS WAITQ THEN OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE RESET;
  BEGIN
  ZEROS     := OBS  := 0;
  QINT      := CUM  := 0.0;
  MAXLENGTH := LENGTH;
  LASTQTIME := RESETAT:= TIME;
  END***RESET***;

  IF THIS QUEUE IS QUEUE THEN JOIN(QUEUEQ);
  END***QUEUE***;


  QUEUE CLASS NOQUEUE;;

  COMMENT------------R E S O U R C E-------------;

  QUEUE CLASS RESOURCE(AVAIL); INTEGER AVAIL;
  BEGIN
                     COMMENT
  * DEFINES THE COMMON CORE TO RES AND BIN
  *
  * VARIABLES:
  *    .AS CLASS QUEUE
  *     AVAIL        AMOUNT OF RESOURCE CURRENTLY FREE
  *     SINT         TO MAINTAIN USAGE*TIME INTEGRAL
  *     EXTREME      MIN VALUE OF AVAIL IF RES
  *                  MAX VALUE OF AVAIL IF BIN
  *     INITIAL      INITIAL VALUE OF THE RESOURCE
  *     LASTRTIME    TIME OF LAST ACQUIRE/RETURN OF RES
  *                  OR LAST TAKE/GET OF BIN
  *
  * PROCEDURES:
  *     REPORT       PRINTS ON ONE LINE
  *        RES =TITLE/RESET/OBS/LIMIT/MIN/NOW/%USAGE/AV.WAIT/QMAX
  *        BIN =TITLE/RESET/OBS/INIT/MAX/NOW/AV.FREE/WAIT/QMAX
  *
  *     RESET        SETS OBS, ZEROS, USERS TO ZERO
  *                  SINT, QINT, CUM TO ZERO
  *                  LASTQTIME, RESETAT TO TIME
  *                  MAXLENGTH TO LENGTH
  *                  EXTREME TO AVAIL
  *;
  INTEGER EXTREME, INITIAL, USERS;
  REAL SINT, LASTRTIME;

  PROCEDURE REPORT;
  BEGIN REAL T, SPAN, X;
  T    := TIME;
  SPAN := T- RESETAT;
  WRITETRN;
  FUDGE: OUTF.IMAGE.SUB(24, 7).PUTINT(USERS);
  OUTF.OUTINT(INITIAL, 5);
  OUTF.OUTINT(EXTREME, 5);
  OUTF.OUTINT(AVAIL, 5);
  X := SINT + (T-LASTRTIME)*AVAIL;
  IF SPAN < EPSILON THEN OUTF.OUTTEXT(MINUSES.SUB(1, 10)) ELSE
  IF THIS RESOURCE IS BIN THEN PRINTREAL(X/SPAN) ELSE
     PRINTREAL((1.0-X/(INITIAL*SPAN))*100.0);
  IF OBS = 0 THEN OUTF.OUTTEXT(MINUSES.SUB(1,10))
             ELSE PRINTREAL(CUM/OBS);
  OUTF.OUTINT(MAXLENGTH,5);
  OUTF.OUTIMAGE;
  END***REPORT***;

  PROCEDURE RESET;
  BEGIN
  OBS := ZEROS := USERS := 0;
  MAXLENGTH := LENGTH;
  LASTRTIME := LASTQTIME := RESETAT := TIME;
  QINT := SINT := CUM := 0.0;
  EXTREME  := AVAIL;
  END***RESET***;

  INITIAL := AVAIL;
  END***RESOURCE***;

  COMMENT------------R E S-----------------------;

  RESOURCE CLASS RES;
  BEGIN
                     COMMENT
  * A RES OBJECT MAKES MUTUAL EXCLISION AVAILABLE IN DEMOS.
  * AN OBJECT WITH LIMIT = N > 0 CAN BE 'USED' BY UP TO
  * N ENTITIES AT A TIME, BUT NO MORE. IT CAN BE SEIZED
  * IN INTEGER CHUNKS (0 < CHUNK <= LIMIT), AND RETURNED
  * ALL AT ONCE OR IN PART CHUNKS. IF THE AMOUNT
  * REQUESTED IS NOT FREE, THE REQUESTER IS DELAYED.
  * WHEN AN ENTITY RETURNS UNITS TO THE RES, THE
  * QUEUE OF BLOCKED ENTITIES IS TESTED FROM THE
  * FRONT.
  *
  * VARIABLES:
  *    .TITLE        USER SUPPLIED DESCRIPTIVE TEXT
  *    .OBS          NO. OF COMPLETED USAGES (CALLS ON RETURN)
  *    .RESETAT      TIME OF CREATION, OR LAST RESET.
  *    .NEXT         REF TO NEXT TAB IN REPORTQ
  *    .AVAIL        AMOUNT CURRENTLY FREE
  *    .SINT         MAINTAINS TIME WEIGHTED AVERAGE OF
  *                   RESOURCE USAGE
  *    .EXTREME      MINIMUM LEVEL REACHED
  *     INITIAL      MAXIMUM LEVEL
  *
  * PROCEDURES:
  *     ACQUIRE(N)   SUCCESS IF N <= AVAIL AND
  *                     CURRENT.PRIORITY > FIRST.PRIORITY
  *                  AND THEN AVAIL := AVAIL - N.
  *                  ELSE CURRENT IS BLOCKED IN THIS QUEUE
  *                 *ERRORS: N < 0
  *                          N > LIMIT
  *
  *     RETURN(N)    AVAIL := AVAIL + N
  *                  ACTIVATE FIRST DELAY 0.0
  *                  (FIRST WILL HIMSELF SEE IF HE CAN GO)
  *                 *ERRORS: N < 0
  *                          N > LIMIT
  *
  *    .REPORT       SEE RESOURCE
  *
  *    .RESET        SEE RESOURCE
  *
  *;

  PROCEDURE ACQUIRE(M); INTEGER M;
  BEGIN
  REAL T;
  IF M < 1 OR M > INITIAL THEN
    ERROR(IF M < 1 THEN 4 ELSE 5, NONE, THIS RES, M,
          "R.AQUIRE(N); REF(RES)R; INTEGER N;");
  CURRENT.INTO(THIS QUEUE);
  CURRENT.WANTS := M;
  IF M > AVAIL OR CURRENT =/= FIRST THEN
  BEGIN
  IF ZYQTRACE>0 THEN NOTE(4,"AWAITS",NONE,THIS RES,0.0,M);
  ZYQPASSIVATE;
  WHILE M > AVAIL OR CURRENT =/= FIRST DO
    ZYQPASSIVATE;
  END;
  IF ZYQTRACE>0 THEN NOTE(5,"SEIZES",NONE,THIS RES,0.0,M);
  T     := TIME;
  SINT  := SINT + (T-LASTRTIME)*AVAIL;
  LASTRTIME := T;
  AVAIL := AVAIL - M;
  IF AVAIL < EXTREME THEN EXTREME := AVAIL;
  CURRENT.OUT;
  CURRENT.WANTS := 0;
  IF (IF FIRST == NONE THEN FALSE ELSE FIRST.WANTS <= AVAIL)
    THEN FIRST.INSERTAFTERCURRENT;
  END***ACQUIRE***;

  PROCEDURE RELEASE(M); INTEGER M;
  BEGIN
  REAL T;
  IF M < 1 OR (AVAIL+M) > INITIAL THEN
    ERROR(IF M < 1 THEN 7 ELSE 8, NONE, THIS RES, M,
          "R.RELEASE(N); REF(RES)R; INTEGER N;");
  IF ZYQTRACE>0 THEN NOTE(6,"RELEASES",NONE,THIS RES,0,M);
  T     := TIME;
  SINT  := SINT + (T-LASTRTIME)*AVAIL;
  LASTRTIME := T;
  AVAIL := AVAIL + M;
  USERS := USERS + 1;
  IF (IF FIRST == NONE THEN FALSE ELSE FIRST.WANTS <= AVAIL)
    THEN FIRST.INSERTDELAY0;
  END***RELEASE***;

  IF AVAIL < 1 THEN
    ERROR(10, NONE, THIS RES, AVAIL,
      "NEW RES(TITLE, LIM); TEXT TITLE; INTEGER LIM;");
  JOIN(RESQ);
  END***RES***;

  COMMENT------------B I N-----------------------;

  RESOURCE CLASS BIN;
  BEGIN
                     COMMENT
  * CLASS BIN CATERS FOR FOR THE PRODUCER/CONSUMER
  * COOPERATION : THE PRODUCER GIVES, THE CONSUMER
  * TAKES.
  *
  * VARIABLES:
  *    .TITLE        USER SUPPLIED DESCRIPTIVE TEXT
  *    .RESETAT      TIME OF CREATION, OR LAST RESET
  *    .OBS          NO. OF COMPLETED USAGES(CALLS ON GIVE)
  *    .NEXT         REF TO NEXT TAB IN BINQ
  *    .AVAIL        AMOUNT CURRENTLY FRCE
  *    .SINT         KEEPS TIME-WEIGHTED AVERAGE OF BIN USAGE
  *    .EXTREME      MAXIMUM LEVEL ATTAINED
  *     INITIAL      INITIAL VALUE OF AVAIL
  *
  * PROCEDURES:
  *     GIVE(M)      INCREMENTS AVAIL BY M
  *                  ACTIVATES FIRST
  *                  *ERRORS : M <= 0
  *
  *     TAKE(M)      BLOCKS CURRENT IF CAN'T PROCEED
  *                   (FIRST IN 0 AND AVAIL > = M)
  *                  WHEN CAN PROCEED, LEAVES Q
  *                  DECREMENTS AVAIL AND ACTIVATES
  *                  FIRST
  *                 *ERROR : M <= 0.
  *
  *    .RESET        SEE RESOURCE
  *
  *    .REPORT       SEE RESOURCE
  *;

  PROCEDURE TAKE(M); INTEGER M;
  BEGIN
  REAL T;
  IF M < 1 THEN
    ERROR(6, NONE, THIS BIN, 0,
          "B.TAKE(M); REF(BIN)B; INTEGER M;");
  CURRENT.INTO(THIS QUEUE);
  CURRENT.WANTS := M;
  IF CURRENT =/= FIRST OR M > AVAIL THEN
  BEGIN
  IF ZYQTRACE>0 THEN NOTE(7,"AWAITS",NONE,THIS BIN,0.0,M);
  ZYQPASSIVATE;
  WHILE CURRENT =/= FIRST OR M > AVAIL DO
    ZYQPASSIVATE;
  END;
  CURRENT.OUT;
  CURRENT.WANTS := 0;
  IF ZYQTRACE>0 THEN NOTE(8,"SEIZES",NONE,THIS BIN,0.0,M);
  T     := TIME;
  SINT  := SINT + (T-LASTRTIME)*AVAIL;
  LASTRTIME := T;
  AVAIL := AVAIL - M;
  IF (IF FIRST == NONE THEN FALSE ELSE FIRST.WANTS <= AVAIL)
    THEN FIRST.INSERTAFTERCURRENT;
  END***TAKE***;

  PROCEDURE GIVE(M); INTEGER M;
  BEGIN
  REAL T;
  IF M < 1 THEN ERROR(9, NONE, THIS BIN, M,
               "B.GIVE(N); REF(BIN)B;  INTEGER N;");
  IF ZYQTRACE>0 THEN NOTE(9,"GIVES",NONE,THIS BIN,0.0,M);
  T := TIME;
  SINT := SINT + (T-LASTRTIME)*AVAIL;
  LASTRTIME := T;
  AVAIL := AVAIL + M;
  USERS := USERS + 1;
  IF AVAIL > EXTREME THEN EXTREME := AVAIL;
  IF (IF FIRST == NONE THEN FALSE ELSE FIRST.WANTS <= AVAIL)
    THEN FIRST.INSERTDELAY0;
  END***GIVE***;

  IF AVAIL < 0 THEN ERROR(11, NONE, THIS BIN, AVAIL,
    "NEW BIN(TITLE, INIT); TEXT TITLE; INTEGER INIT;");
  JOIN(BINQ);
  END***BIN***;

  COMMENT----------------W A I T Q--------------------;

  QUEUE CLASS WAITQ;
  BEGIN
  REF(QUEUE)MASTERQ;

  PROCEDURE WAIT;
  BEGIN
  CURRENT.INTO(THIS QUEUE);
  IF ZYQTRACE>0 THEN NOTE(14,"WAITS",NONE,THIS QUEUE,0.0,0);
  IF MASTERQ.FIRST =/= NONE THEN MASTERQ.FIRST.INSERTDELAY0;
  ZYQPASSIVATE;
  END***WAIT***;

  REF(ENTITY)PROCEDURE COOPT;
  BEGIN
  REF(ENTITY)P;
  CURRENT.INTO(MASTERQ);
  IF LENGTH = 0 OR CURRENT =/= MASTERQ.FIRST THEN
  BEGIN
  IF ZYQTRACE>0 THEN NOTE(17,"WAITS",NONE,MASTERQ,0.0,0);
  ZYQPASSIVATE;
  WHILE LENGTH = 0 DO
    ZYQPASSIVATE;
  P :- CURRENT.SUC;
  IF P =/= NONE AND LENGTH > 1 THEN P.INSERTAFTERCURRENT;
  END;
  CURRENT.OUT;
  P :- COOPT :- FIRST;
  P.COOPT;
  END***COOPT***;

  BOOLEAN PROCEDURE AVAIL(E, C); NAME E, C;
                   REF(ENTITY)E; BOOLEAN C;
  BEGIN
  REF(ENTITY)P;
  E :- P :- FIRST;
  WHILE (IF P == NONE THEN FALSE ELSE NOT C) DO
    P :- E :- P.SUC;
  AVAIL := P =/= NONE;
  END***AVAIL***;

  PROCEDURE FIND(E, C); NAME E, C;
          REF(ENTITY)E; BOOLEAN C;
  BEGIN
  REF(ENTITY)P;
  CURRENT.INTO(MASTERQ);
  IF NOT AVAIL(E, C) THEN
  BEGIN
  IF ZYQTRACE > 0 THEN
    NOTE(15,"IS BLOCKED",NONE,THIS WAITQ,0.0,0);
  ZYQPASSIVATE;
  WHILE NOT AVAIL(E, C) DO
  BEGIN
  IF CURRENT.SUC =/= NONE AND LENGTH > 0 THEN
     CURRENT.SUC.INSERTAFTERCURRENT;
  ZYQPASSIVATE;
  END;
  END;
  P :- CURRENT.SUC;
  CURRENT.OUT;
  E.COOPT;
  IF ZYQTRACE>0 THEN NOTE(16,"FINDS",E,THIS WAITQ,0.0,0);
  IF P =/= NONE AND LENGTH > 0 THEN P.INSERTAFTERCURRENT;
  END***FIND***;

  MASTERQ :- NEW NOQUEUE(TITLE);
  MASTERQ.JOIN(WAITQQ);
  JOIN(WAITQQ);
  END***WAITQ***;

  COMMENT---------------C O N D Q-------------------;

  QUEUE CLASS CONDQ;
  BEGIN
                      COMMENT
  * CONDQ SUPPLIES THE WAITUNTIL CAPABILITY TO DEMOS.
  * AN ENTITY WAITING UNTIL TESTS THE CONDITION AT
  * ONCE: IF TRUE, IT PROCEEDS WITHOUT DELAY.
  * OTHERWISE IT IS DELAYED UNTIL SIGNALLED TO GO ON.
  * IF ALL IS SET, SIGNAL CHECKS EACH AND EVERY ENTITY
  * WAITING UNTIL. ELSE ONLY THOSE AT THE HEAD OF THE
  * QUEUE ARE TESTED.
  *
  * VARIABLES:
  *    .AS QUEUE
  *     ALL         SIGNAL TESTS ALL WAITING ENTITIES IF SET
  *
  * PROCEDURES:
  *     WAITUNTIL   KEEPS AN ENTITY IN THIS CONDQ
  *                  UNTIL THE CONDITION IS FULFILLED
  *
  *     SIGNAL      ISSUED BY AN ENTITY ON FREEING SYSTEM
  *                  RESOURCES. TESTS DORMANT ENTITIES
  *;

  BOOLEAN ALL;

  PROCEDURE WAITUNTIL(C); NAME C; BOOLEAN C;
  BEGIN
  CURRENT.INTO(THIS CONDQ);
  IF NOT C THEN
  BEGIN
  IF ZYQTRACE > 0 THEN
    NOTE(19,"W'UNTIL IN", NONE,THIS CONDQ,0.0,0);
  ZYQPASSIVATE;
  WHILE NOT C DO
  BEGIN
  IF ALL AND CURRENT.SUC =/= NONE THEN
    CURRENT.SUC.INSERTAFTERCURRENT;
  ZYQPASSIVATE;
  END;
  IF ZYQTRACE>0 THEN NOTE(20,"LEAVES",NONE,THIS CONDQ,0.0,0);
  END;
  IF CURRENT.SUC=/=NONE THEN CURRENT.SUC.INSERTAFTERCURRENT;
  CURRENT.OUT;
  END***WAITUNTIL***;

  PROCEDURE SIGNAL;
  BEGIN
  IF ZYQTRACE > 0 THEN
    NOTE(25, "SIGNALS",  NONE, THIS CONDQ, 0.0, 0);
  IF LENGTH > 0 THEN FIRST.INSERTDELAY0;
  END***SIGNAL***;

  JOIN(CONDQQ);
  END***CONDQ***;

  COMMENT----------T R A C I N G   R O U T I N E S-------------;

  REAL ZYQNOTELASTT;  REF(ENTITY)ZYQNOTELASTE;  INTEGER ZYQTRACE;

  PROCEDURE TRACE;
  IF ZYQTRACE > 0 THEN ZYQTRACE := ZYQTRACE+1 ELSE
  BEGIN OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  CLOCKTIME;
  BOX("T R A C I N G   C O M M E N C E S");
  OUTF.OUTTEXT("      TIME/ CURRENT     AND ITS ACTION(S)");
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  ZYQTRACE := 1;
  END***TRACE***;

  PROCEDURE NOTRACE;
  IF ZYQTRACE > 1 THEN ZYQTRACE := ZYQTRACE-1 ELSE
  BEGIN OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  CLOCKTIME;
  BOX("T R A C I N G   S W I T C H E D   O F F");
  ZYQTRACE := 0;
  ZYQNOTELASTT := -15.0;
  ZYQNOTELASTE :- NONE;
  END***NOTRACE***;

  PROCEDURE NOTE(INDEX,ACTION,E,L,T1,N);VALUE ACTION;TEXT ACTION;
              INTEGER INDEX, N; REAL T1; REF(ENTITY)E; REF(TAB)L;
  BEGIN REAL T; REF(ENTITY)C;

  PROCEDURE INTOUT(N); INTEGER N;
  BEGIN INTEGER P;
  IF N < 0 THEN
  BEGIN
  N := -N;
  OUTF.OUTCHAR('-');
  END;
  P := IF N < 10 THEN 1 ELSE
       IF N < 100 THEN 2 ELSE
       IF N < 1000 THEN 3 ELSE
       IF N < 10000 THEN 4 ELSE
       IF N < 100000 THEN 5 ELSE 10;
  OUTF.OUTINT(N, P);
  END***INTOUT***;

  PROCEDURE REALOUT(X); REAL X;
  BEGIN INTEGER P;
  IF X < 0 THEN
  BEGIN
  X := -X;
  OUTF.OUTCHAR('-');
  END;
  P := IF X < 10.0 THEN 5 ELSE
       IF X < 100.0 THEN 6 ELSE
       IF X < 1000.0 THEN 7 ELSE
       IF X < 10000.0 THEN 8 ELSE
       IF X < 100000.0 THEN 9 ELSE 0;
  IF P = 0 THEN OUTF.OUTREAL(X, 5, 10) ELSE OUTF.OUTFIX(X, 3, P);
  END***REALOUT***;

  SWITCH MESSAGE := M1, M2, M3, M4, M5, M6, M7, M8, M9,
                    M10,M11,M12,M13,M14,M15,M16,M17,M18,
                    M19,M20,M21,M22,M23,M24,M25;
  T := TIME;
  C :- CURRENT;
  IF (ABS(T)-ZYQNOTELASTT) > 0.0005 THEN
  BEGIN ZYQNOTELASTT := T;
  PRINTREAL(T);
  END;
  IF ZYQNOTELASTE =/= C THEN
  BEGIN OUTF.SETPOS(12);
  ZYQNOTELASTE :- C;
  OUTF.OUTTEXT(C.TITLE);
  END;

  OUTF.SETPOS(25);
  OUTF.OUTTEXT(ACTION);
  OUTF.OUTCHAR(' ');
  GOTO MESSAGE(INDEX);

  M1:     COMMENT E.COOPT;
  M18:    COMMENT Q.COOPT     - COOPTS;
  M23:    COMMENT CANCEL(E);
          IF E == NONE THEN OUTF.OUTTEXT("NONE~") ELSE
          IF E == CURRENT THEN OUTF.OUTTEXT("ITSELF")
                          ELSE OUTF.OUTTEXT(E.TITLE);
          IF L =/= NONE THEN
          BEGIN OUTF.OUTTEXT(" FROM ");
            OUTF.OUTTEXT(L.TITLE);
          END;
          GOTO EXIT;

  M2:     COMMENT E.SCHEDULE(T);
          OUTF.OUTTEXT(E.TITLE);
          IF T1 <= 0.0 THEN OUTF.OUTTEXT(" NOW") ELSE
          BEGIN OUTF.OUTTEXT(" AT ");
            REALOUT(T+T1);
          END;
          GOTO EXIT;

  M3:     COMMENT TERMINATES;
          GOTO EXIT;

  M4:     COMMENT RES.ACQUIRE - BLOCKED;
  M5:     COMMENT RES.ACQUIRE - SEIZES;
  M6:     COMMENT RES.RELEASE - RELEASES;
  M7:     COMMENT BIN.TAKE    - BLOCKED;
  M8:     COMMENT BIN.TAKE    - SEIZES;
  M9:     COMMENT BIN.GIVE    - RELEASES;
          INTOUT(N);
          IF INDEX=6 OR INDEX=9 THEN OUTF.OUTTEXT(" TO ")
                                ELSE OUTF.OUTTEXT(" OF ");
          OUTF.OUTTEXT(L.TITLE);
          GOTO EXIT;

  M16:    COMMENT Q.FIND      - FINDS;
          OUTF.OUTTEXT(E.TITLE);
          OUTF.OUTCHAR(' ');

  M14:    COMMENT Q.WAIT;
  M15:    COMMENT Q.FIND      - BLOCKED;
  M17:    COMMENT Q.COOPT     - BLOCKED;
          OUTF.OUTTEXT("IN ");

  M19:    COMMENT Q.WAITUNTIL - WAITS;
  M20:    COMMENT Q.WAITUNTIL - LEAVES;
  M25:    COMMENT Q.SIGNAL;
          OUTF.OUTTEXT(L.TITLE);
          GOTO EXIT;

  M21:    COMMENT HOLDS;
          REALOUT(T1);
          OUTF.OUTTEXT(", UNTIL ");
          REALOUT(T+T1);
          GOTO EXIT;

  M22:    COMMENT ZYQPASSIVATE;
          GOTO EXIT;

  M24:    COMMENT E.INTERRUPT(N);
          OUTF.OUTTEXT(E.TITLE);
          OUTF.OUTTEXT(", WITH N = ");
          INTOUT(N);
          GOTO EXIT;

    M10:M11:M12:M13:
  EXIT:   OUTF.OUTIMAGE;
  END***NOTE***;

  PROCEDURE ERROR(NO, E, Q, N, CALL);
           VALUE CALL; INTEGER NO, N;
           TEXT CALL; REF(ENTITY)E; REF(TAB)Q;
  BEGIN

  PROCEDURE NEXTLINE;
  BEGIN
  OUTCHAR('.');
  OUTIMAGE;
  SYSOUT.SETPOS(9);
  END***NEXTLINE***;

  PROCEDURE INTOUT(N); INTEGER N;
  BEGIN INTEGER P;
  OUTCHAR(' ');
  IF N < 0 THEN
  BEGIN
  N := -N;
  OUTCHAR('-');
  END;
  P := IF N < 10 THEN 1 ELSE
       IF N < 100 THEN 2 ELSE
       IF N < 1000 THEN 3 ELSE
       IF N < 10000 THEN 4 ELSE
       IF N < 100000 THEN 5 ELSE 10;
  OUTINT(N, P);
  END***INTOUT***;

  PROCEDURE PRINTREAL(X); REAL X;
  BEGIN INTEGER P;
  OUTCHAR(' ');
  IF X < 0 THEN
  BEGIN
  X := -X;
  OUTCHAR('-');
  END;
  P := IF X < 10.0 THEN 5 ELSE
       IF X < 100.0 THEN 6 ELSE
       IF X < 1000.0 THEN 7 ELSE
       IF X < 10000.0 THEN 8 ELSE
       IF X < 100000.0 THEN 9 ELSE 0;
  IF P = 0 THEN OUTREAL(X, 5, 10) ELSE OUTFIX(X, 3, P);
  END***PRINTREAL***;

  REF(ENTITY)C;
  SWITCH CASE := E1, E2, E3, E4, E5, E6, E7, E8, E9, E10,
                 E11,E12,E13,E14,E15,E16,E17,E18,E19,E20;

  SYSOUT.SETPOS(23);
  OUTTEXT("CLOCK TIME = ");
  IF TIME > 99999.0 THEN OUTREAL(TIME, 5, 12)
                    ELSE OUTFIX(TIME, 3, 10);
  OUTIMAGE;
  ABORT(FALSE);

  OUTTEXT("**CAUSE : CALL ON '");
  OUTTEXT(CALL);
  OUTCHAR(''');
  NEXTLINE;

  OUTTEXT("CURRENT == ");
  OUTTEXT(CURRENT.TITLE);
  NEXTLINE;
  GOTO CASE(NO);

  E1:         COMMENT E.COOPT;
      OUTTEXT("ATTEMPT BY CURRENT TO COOPT '");
      OUTTEXT(E.TITLE);
      OUTCHAR(''');
      NEXTLINE;
      OUTTEXT(E.TITLE);
      OUTTEXT(" IS ALREADY COOPTED BY ");
      OUTTEXT(E.OWNER.TITLE);
      GOTO BLOWUP;

  E2:     COMMENT E.INTO(Q);
      OUTTEXT("Q == NONE");
      NEXTLINE;
      OUTTEXT("ATTEMPT BY CURRENT TO PLACE ");
      IF E == CURRENT THEN OUTTEXT("ITSELF")
              ELSE OUTTEXT(E.TITLE);
      OUTTEXT(" INTO A NULL QUEUE");
      NEXTLINE;
      OUTTEXT("STATEMENT IGNORED.");
      GOTO CONTINUE;

  E3:     COMMENT E.INTO(Q);
      OUTTEXT("CURRENT TRIES TO PLACE ");
      IF E == CURRENT THEN OUTTEXT("ITSELF")
              ELSE OUTTEXT(E.TITLE);
      OUTTEXT(" INTO QUEUE '");
      OUTTEXT(Q.TITLE);  OUTCHAR(''');
      NEXTLINE;
      OUTTEXT(E.TITLE);
      OUTTEXT(" IS ALREADY IN ");
      OUTTEXT(E.CURRENTQ.TITLE);
      NEXTLINE;
      OUTTEXT(E.TITLE);
      OUTTEXT(" LEAVES ");
      OUTTEXT(E.CURRENTQ.TITLE);
      OUTTEXT(" AND ENTERS ");
      IF Q == NONE THEN OUTTEXT("A NULL QUEUE~")
               ELSE OUTTEXT(Q.TITLE);
      GOTO CONTINUE;

  E4:     COMMENT R.ACQUIRE(N) : N < 0;
  E5:     COMMENT R.ACQUIRE(N) : N > R.LIMIT;
  E6:     COMMENT B.TAKE(N)    : N < 0;
  E7:     COMMENT R.RELEASE(N) : N < 0;
  E8:     COMMENT R.RELEASE(N) : N > R.LIMIT;
  E9:     COMMENT B.GIVE(N)    : N < 0;
      OUTTEXT("N =");
      INTOUT(N);
      NEXTLINE;
      IF NO <= 6 THEN OUTTEXT("REQUEST FOR ")
             ELSE OUTTEXT("ATTEMPT TO RETURN ");
      IF N < 1 THEN OUTTEXT("NON-POSITIVE")
           ELSE OUTTEXT("TOO MANY");
      OUTTEXT(" UNITS ");
      IF NO <= 6 THEN OUTTEXT("FROM ") ELSE OUTTEXT("TO ");
      IF Q IN RES THEN OUTTEXT("RES") ELSE OUTTEXT("BIN");
      OUTCHAR(' ');  OUTCHAR(''');
      OUTTEXT(Q.TITLE);  OUTCHAR(''');
      NEXTLINE;
      IF Q IN BIN THEN OUTTEXT("SET N > 0") ELSE
      BEGIN
      OUTTEXT("SET 0 < N <= R.LIMIT (=");
      INTOUT(Q QUA RESOURCE.INITIAL);
      OUTCHAR(')');
      END;
      GOTO BLOWUP;

  E10:    COMMENT NEW RES(TITLE, LIMIT);
  E11:    COMMENT NEW BIN(TITLE, INITIAL SIZE);
      IF NO = 10 THEN OUTTEXT("LIMIT OF RES '")
         ELSE OUTTEXT("INITIAL SIZE OF BIN '");
      OUTTEXT(Q.TITLE);
      OUTTEXT("' =");
      INTOUT(N);
      NEXTLINE;
      OUTTEXT("IT SHOULD BE ");
      IF NO=10 THEN OUTTEXT("POSITIVE")
           ELSE OUTTEXT("NON-NEGATIVE");
      OUTCHAR('.');  OUTCHAR(' ');
      IF NO=10 THEN OUTTEXT("SET LIMIT > 0")
           ELSE OUTTEXT("SET INITIAL SIZE >= 0");
      GOTO BLOWUP;

  E12:    COMMENT X.CANCEL : X IDLE;
      OUTTEXT("ENTITY '");
      OUTTEXT(E.TITLE);
      OUTTEXT("' IS NOT IN THE EVENT LIST.");
      OUTIMAGE;
      GOTO CONTINUE;

  E13:    COMMENT X.CANCEL : X SOLE ENTITY IN EVENT LIST;
      OUTTEXT("ATTEMPT TO CANCEL LAST ENTITY IN EVENT LIST");
      GOTO BLOWUP;

  E14:    COMMENT E.SCHEDULE(T) : E TERMINATED;
      OUTTEXT("E == '");
      OUTTEXT(E.TITLE);
      OUTTEXT("' IS TERMINATED AND CANNOT BE SCHEDULED");
      GOTO BLOWUP;

  E15:    COMMENT IMPLEMENTATION ERROR;
      OUTTEXT("SYSTEM ERROR: PLEASE CONTACT THE  ");
      OUTTEXT("IMPLEMENTOR, GRAHAM BIRTWISTLE.");
      GOTO BLOWUP;

  E16:    COMMENT E.SCHEDULE(T): REF(ENTITY)T: REAL T;
      OUTTEXT("E == '");
      OUTTEXT(E.TITLE);
      OUTTEXT("' IS ALREADY SCHEDULED.");
      GOTO JOIN;

  E17:    COMMENT E.CANCEL: REF(ENTITY)E;
      OUTTEXT("ATTEMPT TO CANCEL NON-SCHEDULED ENTITY E == '");
      OUTTEXT(E.TITLE);  OUTCHAR(''');
  JOIN:   NEXTLINE;
      OUTTEXT("STATEMENT IGNORED.");
      GOTO CONTINUE;

  E18:    COMMENT T.JOIN(R): REF(TAB)T: REF(REPORTQ)R;
      OUTTEXT("TAB '");
      OUTTEXT(Q.TITLE);
      OUTTEXT("' TRIES TO JOIN A NULL REPORTQ");
      NEXTLINE;
      OUTTEXT("T WILL NOT BE REPORTED UNLESS YOU ");
      OUTTEXT(" CALL 'T.REPORT'.");
      GOTO CONTINUE;

  E19:    COMMENT NEW HISTOGRAM(T, L, U, N);
      OUTTEXT("ATTEMPT TO CREATE ILLEGAL HISTOGRAM '");
      OUTTEXT(Q.TITLE);
      OUTCHAR(''');
      NEXTLINE;
      OUTTEXT("LOWER BOUND = ");
      PRINTREAL(Q QUA HISTOGRAM.LOWER);
      NEXTLINE;
      OUTTEXT("UPPER BOUND = ");
      PRINTREAL(Q QUA HISTOGRAM.UPPER);
      NEXTLINE;
      OUTTEXT("UPPER MUST BE GREATER THAN LOWER");
      NEXTLINE;
      OUTTEXT("ACTION: LOWER <- 0.0, AND UPPER <- 100.0.");
      GOTO CONTINUE;

  E20:    COMMENT NEW EMPIRICAL(T, 1);
      OUTTEXT("ATTEMPT TO CREATE EMPIRICAL OBJECT '");
      OUTTEXT(Q.TITLE);  OUTCHAR(''');
      NEXTLINE;
      OUTTEXT("SIZE = 1. SET SIZE > 1");
      GOTO BLOWUP;

  BLOWUP:     OUTCHAR('.'); OUTIMAGE;
          ABORT(TRUE);
  CONTINUE:   OUTIMAGE; OUTIMAGE;
  END***ERROR***;

  PROCEDURE ABORT(B); BOOLEAN B;
  BEGIN
  INTEGER L;
  IF B THEN L := 27 ELSE L := 28;
  OUTTEXT(MINUSES);  OUTIMAGE;
  OUTTEXT(MINUSES.SUB(1, L));
  IF B THEN OUTTEXT("PROGRAM  ABORTED")
       ELSE OUTTEXT("SERIOUS  ERROR");
  OUTTEXT(MINUSES.SUB(1, L));  OUTIMAGE;
  OUTTEXT(MINUSES);  OUTIMAGE;
  IF B THEN
  BEGIN
  IF INF =/= SYSIN AND INF.IMAGE =/= NOTEXT THEN INF.CLOSE;
  IF OUTF =/= SYSOUT AND OUTF.IMAGE =/= NOTEXT THEN OUTF.CLOSE;
  L := 0;
  L := 1/L;
  END;
  END***ABORT***;

  COMMENT---------S N A P P I N G   R O U T I N E S------------;

  PROCEDURE REPORT;
  BEGIN REF(REPORTQ)R;
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  CLOCKTIME;
  BOX("R E P O R T");
  FOR R:-DISTQ,EMPQ,ACCUMQ,COUNTQ,TALLYQ,HISTOQ,REGRESSQ,
         RESQ,BINQ,QUEUEQ,WAITQQ,CONDQQ DO
  IF R.FIRST =/= NONE THEN
  BEGIN
  OUTF.OUTIMAGE;
  OUTF.OUTIMAGE;
  R.REPORT;
  END;
  END***REPORT***;

  PROCEDURE NOREPORT;
    ZYQREPORT := FALSE;

  PROCEDURE RESET;
  BEGIN REF(REPORTQ)R;
  FOR R:-DISTQ,EMPQ,ACCUMQ,COUNTQ,TALLYQ,HISTOQ,REGRESSQ,
        RESQ,BINQ,QUEUEQ,WAITQQ,CONDQQ DO
  IF R.FIRST =/= NONE THEN R.RESET;
  END***RESET***;

  PROCEDURE SNAPQUEUES;
  BEGIN REF(TAB)Q; INTEGER K; REF(ENTITY)E;
  OUTF.OUTIMAGE; OUTF.OUTIMAGE;
  CLOCKTIME;
  BOX("L I S T   O F   P A S S I V E   O B J E C T S");
  FOR Q :- QUEUEQ.FIRST, CONDQQ.FIRST, WAITQQ.FIRST DO
  BEGIN
  WHILE Q =/= NONE DO
  BEGIN
  Q QUA QUEUE.LIST;
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  Q :- Q.NEXT;
  END;
  OUTF.OUTIMAGE; OUTF.OUTIMAGE;
  END;
  END***SNAPQUEUES***;

  PROCEDURE SNAPSQS;
  BEGIN INTEGER K;
  PROCEDURE TRAVERSE(R); REF(ENTITY)R;
  BEGIN
  IF R.LL =/= NONE THEN TRAVERSE(R.LL);
  IF R.RL =/= NONE THEN TRAVERSE(R.RL);
  K := K+1;  OUTF.OUTINT(K, 5);  R.LIST;
  END***TRAVERSE***;

  OUTF.OUTIMAGE; OUTF.OUTIMAGE;
  CLOCKTIME;
  BOX("E V E N T   L I S T");
  OUTF.OUTTEXT("    N/ EV. TIME/OBJ. TITLE / ");
  OUTF.OUTTEXT("LL           BL           RL");
  OUTF.OUTIMAGE;
  TRAVERSE(ROOT);
  OUTF.OUTIMAGE;  OUTF.OUTIMAGE;
  END***SNAPSQS***;

  ENTITY CLASS MAINPROGRAM;
  BEGIN
  LOOP:
  DETACH;
  GOTO LOOP;
  END***MAINPROGRAM***;

  CLASS ZYQENTTITLE(T); TEXT T;
  BEGIN INTEGER N, L;
  REF(ZYQENTTITLE)NEXTTITLE;
  NEXTTITLE   :- ZYQENTNAMES;
  ZYQENTNAMES :- THIS ZYQENTTITLE;
  L := T.LENGTH;
  N := 1;
  END***ZYQENTTITLE***;

  COMMENT--------LOCAL VARIABLES AND THEIR INITIALISATIONS ----;

  REF(REPORTQ)EMPQ, TALLYQ, ACCUMQ, HISTOQ, COUNTQ, DISTQ;
  REF(REPORTQ)RESQ, BINQ, QUEUEQ, CONDQQ, WAITQQ, REGRESSQ;
  TEXT TALLYHEADING, ACCUMHEADING, DISTHEADING;
  TEXT HEADINGRTN, STARS, MINUSES, ZYQREASON, ZYQRECVRY;
  TEXT RESHEADING, BINHEADING, QHEADING;
  TEXT ARRAY DISTTYPE(0:9);
  INTEGER ZYQSEED, ZYQMODULO;
  REF(INFILE)INF;
  REF(OUTFILE)OUTF;
  REF(ZYQENTTITLE)ZYQENTNAMES;
  REF(MAINPROGRAM)DEMOS;
  REF(ENTITY)ROOT, CURRENT;
  REAL NOW, SIMPERIOD, EPSILON;
  BOOLEAN ZYQREPORT;

  ZYQREPORT := TRUE;

  EPSILON := 0.00001;

  HEADINGRTN  :-COPY("TITLE       /   (RE)SET/   OBS");
  ACCUMHEADING:-COPY("/  AVERAGE/EST.ST.DV/  MINIMUM/  MAXIMUM");
  DISTHEADING :-COPY("/TYPE     /        A/        B/     SEED");
  TALLYHEADING:-ACCUMHEADING;
  RESHEADING  :-COPY("/ LIM/ MIN/ NOW/  % USAGE/ AV. WAIT/QMAX");
  BINHEADING  :-COPY("/INIT/ MAX/ NOW/ AV. FREE/ AV. WAIT/QMAX");
  QHEADING    :-COPY("/ QMAX/ QNOW/ Q AVERAGE/ZEROS/  AV. WAIT");

  DISTTYPE(0) :-COPY("UNDEFINED");
  DISTTYPE(1) :-COPY("NORMAL");   DISTTYPE(2) :-COPY("UNIFORM");
  DISTTYPE(3) :-COPY("ERLANG");   DISTTYPE(4) :-COPY("RANDINT");
  DISTTYPE(5) :-COPY("NEGEXP");   DISTTYPE(6) :-COPY("POISSON");
  DISTTYPE(7) :-COPY("DRAW");     DISTTYPE(8) :-COPY("CONSTANT");
  DISTTYPE(9) :-COPY("EMPIRICAL");

  ACCUMQ :- NEW REPORTQ("A C C U M U L A T E S",
                            HEADINGRTN, ACCUMHEADING);
  COUNTQ :- NEW REPORTQ("C O U N T S", BLANKS(20), HEADINGRTN);
  DISTQ  :- NEW REPORTQ("D I S T R I B U T I O N S",
                            HEADINGRTN, DISTHEADING );
  EMPQ   :- NEW REPORTQ("E M P I R I C A L S", NOTEXT, NOTEXT);
  REGRESSQ:-NEW REPORTQ("R E G R E S S I O N S",NOTEXT,NOTEXT);
  HISTOQ :- NEW REPORTQ("H I S T O G R A M S", NOTEXT, NOTEXT);
  TALLYQ :- NEW REPORTQ("T A L L I E S",HEADINGRTN,TALLYHEADING);
  RESQ   :- NEW REPORTQ("R E S O U R C E S",HEADINGRTN,
                                            RESHEADING);
  BINQ   :- NEW REPORTQ("B I N S",HEADINGRTN,BINHEADING);
  QUEUEQ :- NEW REPORTQ("Q U E U E S",HEADINGRTN,QHEADING);
  CONDQQ :- NEW REPORTQ("C O N D I T I O N   Q U E U E S",
                            HEADINGRTN, QHEADING);
  WAITQQ :- NEW REPORTQ("W A I T   Q U E U E S",
                            HEADINGRTN, QHEADING);

  STARS :- BLANKS(70);
  WHILE STARS.MORE DO
    STARS.PUTCHAR('*');

  MINUSES :- BLANKS(70);
  WHILE MINUSES.MORE DO
    MINUSES.PUTCHAR('-');

  INF       :- SYSIN;
  OUTF      :- SYSOUT;
  ZYQREASON :- COPY("**REASON   : ");
  ZYQRECVRY :- COPY("**RECOVERY : ");
  ZYQMODULO := 67099547;  ZYQSEED := 907;
  NOW := -10&20;
  ZYQNOTELASTT := -15.0;
  CURRENT :- ROOT  :- DEMOS :- NEW MAINPROGRAM("DEMOS");
  DEMOS.EVTIME := 0.0;
  DEMOS.TITLE :- DEMOS.TITLE.SUB(1, 5);
  INNER;
                 WHILE (IF DEMOS==ROOT THEN FALSE ELSE
                        DEMOS.BL.EVTIME<=DEMOS.EVTIME) DO
  BEGIN
  HOLD(0.0);
  END;
  IF ZYQREPORT THEN REPORT;
  IF INF =/= SYSIN AND INF.IMAGE =/= NOTEXT THEN INF.CLOSE;
  IF OUTF =/= SYSOUT AND OUTF.IMAGE =/= NOTEXT THEN OUTF.CLOSE;
  END***DEMOS***;