.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "URI 3"
.TH URI 3 "2019-01-09" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
URI \- Uniform Resource Identifiers (absolute and relative)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use URI;
\&
\& $u1 = URI\->new("http://www.perl.com");
\& $u2 = URI\->new("foo", "http");
\& $u3 = $u2\->abs($u1);
\& $u4 = $u3\->clone;
\& $u5 = URI\->new("HTTP://WWW.perl.com:80")\->canonical;
\&
\& $str = $u\->as_string;
\& $str = "$u";
\&
\& $scheme = $u\->scheme;
\& $opaque = $u\->opaque;
\& $path   = $u\->path;
\& $frag   = $u\->fragment;
\&
\& $u\->scheme("ftp");
\& $u\->host("ftp.perl.com");
\& $u\->path("cpan/");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the \f(CW\*(C`URI\*(C'\fR class.  Objects of this class
represent \*(L"Uniform Resource Identifier references\*(R" as specified in \s-1RFC
2396\s0 (and updated by \s-1RFC 2732\s0).
.PP
A Uniform Resource Identifier is a compact string of characters that
identifies an abstract or physical resource.  A Uniform Resource
Identifier can be further classified as either a Uniform Resource Locator
(\s-1URL\s0) or a Uniform Resource Name (\s-1URN\s0).  The distinction between \s-1URL\s0
and \s-1URN\s0 does not matter to the \f(CW\*(C`URI\*(C'\fR class interface. A
\&\*(L"URI-reference\*(R" is a \s-1URI\s0 that may have additional information attached
in the form of a fragment identifier.
.PP
An absolute \s-1URI\s0 reference consists of three parts:  a \fIscheme\fR, a
\&\fIscheme-specific part\fR and a \fIfragment\fR identifier.  A subset of \s-1URI\s0
references share a common syntax for hierarchical namespaces.  For
these, the scheme-specific part is further broken down into
\&\fIauthority\fR, \fIpath\fR and \fIquery\fR components.  These URIs can also
take the form of relative \s-1URI\s0 references, where the scheme (and
usually also the authority) component is missing, but implied by the
context of the \s-1URI\s0 reference.  The three forms of \s-1URI\s0 reference
syntax are summarized as follows:
.PP
.Vb 3
\&  <scheme>:<scheme\-specific\-part>#<fragment>
\&  <scheme>://<authority><path>?<query>#<fragment>
\&  <path>?<query>#<fragment>
.Ve
.PP
The components into which a \s-1URI\s0 reference can be divided depend on the
\&\fIscheme\fR.  The \f(CW\*(C`URI\*(C'\fR class provides methods to get and set the
individual components.  The methods available for a specific
\&\f(CW\*(C`URI\*(C'\fR object depend on the scheme.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
The following methods construct new \f(CW\*(C`URI\*(C'\fR objects:
.ie n .IP "$uri = \s-1URI\-\s0>new( $str )" 4
.el .IP "\f(CW$uri\fR = \s-1URI\-\s0>new( \f(CW$str\fR )" 4
.IX Item "$uri = URI->new( $str )"
.PD 0
.ie n .IP "$uri = \s-1URI\-\s0>new( $str, $scheme )" 4
.el .IP "\f(CW$uri\fR = \s-1URI\-\s0>new( \f(CW$str\fR, \f(CW$scheme\fR )" 4
.IX Item "$uri = URI->new( $str, $scheme )"
.PD
Constructs a new \s-1URI\s0 object.  The string
representation of a \s-1URI\s0 is given as argument, together with an optional
scheme specification.  Common \s-1URI\s0 wrappers like "" and <>, as well as
leading and trailing white space, are automatically removed from
the \f(CW$str\fR argument before it is processed further.
.Sp
The constructor determines the scheme, maps this to an appropriate
\&\s-1URI\s0 subclass, constructs a new object of that class and returns it.
.Sp
If the scheme isn't one of those that \s-1URI\s0 recognizes, you still get
an \s-1URI\s0 object back that you can access the generic methods on.  The
\&\f(CW\*(C`$uri\->has_recognized_scheme\*(C'\fR method can be used to test for
this.
.Sp
The \f(CW$scheme\fR argument is only used when \f(CW$str\fR is a
relative \s-1URI.\s0  It can be either a simple string that
denotes the scheme, a string containing an absolute \s-1URI\s0 reference, or
an absolute \f(CW\*(C`URI\*(C'\fR object.  If no \f(CW$scheme\fR is specified for a relative
\&\s-1URI\s0 \f(CW$str\fR, then \f(CW$str\fR is simply treated as a generic \s-1URI\s0 (no scheme-specific
methods available).
.Sp
The set of characters available for building \s-1URI\s0 references is
restricted (see URI::Escape).  Characters outside this set are
automatically escaped by the \s-1URI\s0 constructor.
.ie n .IP "$uri = \s-1URI\-\s0>new_abs( $str, $base_uri )" 4
.el .IP "\f(CW$uri\fR = \s-1URI\-\s0>new_abs( \f(CW$str\fR, \f(CW$base_uri\fR )" 4
.IX Item "$uri = URI->new_abs( $str, $base_uri )"
Constructs a new absolute \s-1URI\s0 object.  The \f(CW$str\fR argument can
denote a relative or absolute \s-1URI.\s0  If relative, then it is
absolutized using \f(CW$base_uri\fR as base. The \f(CW$base_uri\fR must be an absolute
\&\s-1URI.\s0
.ie n .IP "$uri = URI::file\->new( $filename )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new( \f(CW$filename\fR )" 4
.IX Item "$uri = URI::file->new( $filename )"
.PD 0
.ie n .IP "$uri = URI::file\->new( $filename, $os )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new( \f(CW$filename\fR, \f(CW$os\fR )" 4
.IX Item "$uri = URI::file->new( $filename, $os )"
.PD
Constructs a new \fIfile\fR \s-1URI\s0 from a file name.  See URI::file.
.ie n .IP "$uri = URI::file\->new_abs( $filename )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new_abs( \f(CW$filename\fR )" 4
.IX Item "$uri = URI::file->new_abs( $filename )"
.PD 0
.ie n .IP "$uri = URI::file\->new_abs( $filename, $os )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new_abs( \f(CW$filename\fR, \f(CW$os\fR )" 4
.IX Item "$uri = URI::file->new_abs( $filename, $os )"
.PD
Constructs a new absolute \fIfile\fR \s-1URI\s0 from a file name.  See
URI::file.
.ie n .IP "$uri = URI::file\->cwd" 4
.el .IP "\f(CW$uri\fR = URI::file\->cwd" 4
.IX Item "$uri = URI::file->cwd"
Returns the current working directory as a \fIfile\fR \s-1URI.\s0  See
URI::file.
.ie n .IP "$uri\->clone" 4
.el .IP "\f(CW$uri\fR\->clone" 4
.IX Item "$uri->clone"
Returns a copy of the \f(CW$uri\fR.
.SH "COMMON METHODS"
.IX Header "COMMON METHODS"
The methods described in this section are available for all \f(CW\*(C`URI\*(C'\fR
objects.
.PP
Methods that give access to components of a \s-1URI\s0 always return the
old value of the component.  The value returned is \f(CW\*(C`undef\*(C'\fR if the
component was not present.  There is generally a difference between a
component that is empty (represented as \f(CW""\fR) and a component that is
missing (represented as \f(CW\*(C`undef\*(C'\fR).  If an accessor method is given an
argument, it updates the corresponding component in addition to
returning the old value of the component.  Passing an undefined
argument removes the component (if possible).  The description of
each accessor method indicates whether the component is passed as
an escaped (percent-encoded) or an unescaped string.  A component that can be further
divided into sub-parts are usually passed escaped, as unescaping might
change its semantics.
.PP
The common methods available for all \s-1URI\s0 are:
.ie n .IP "$uri\->scheme" 4
.el .IP "\f(CW$uri\fR\->scheme" 4
.IX Item "$uri->scheme"
.PD 0
.ie n .IP "$uri\->scheme( $new_scheme )" 4
.el .IP "\f(CW$uri\fR\->scheme( \f(CW$new_scheme\fR )" 4
.IX Item "$uri->scheme( $new_scheme )"
.PD
Sets and returns the scheme part of the \f(CW$uri\fR.  If the \f(CW$uri\fR is
relative, then \f(CW$uri\fR\->scheme returns \f(CW\*(C`undef\*(C'\fR.  If called with an
argument, it updates the scheme of \f(CW$uri\fR, possibly changing the
class of \f(CW$uri\fR, and returns the old scheme value.  The method croaks
if the new scheme name is illegal; a scheme name must begin with a
letter and must consist of only US-ASCII letters, numbers, and a few
special marks: \*(L".\*(R", \*(L"+\*(R", \*(L"\-\*(R".  This restriction effectively means
that the scheme must be passed unescaped.  Passing an undefined
argument to the scheme method makes the \s-1URI\s0 relative (if possible).
.Sp
Letter case does not matter for scheme names.  The string
returned by \f(CW$uri\fR\->scheme is always lowercase.  If you want the scheme
just as it was written in the \s-1URI\s0 in its original case,
you can use the \f(CW$uri\fR\->_scheme method instead.
.ie n .IP "$uri\->has_recognized_scheme" 4
.el .IP "\f(CW$uri\fR\->has_recognized_scheme" 4
.IX Item "$uri->has_recognized_scheme"
Returns \s-1TRUE\s0 if the \s-1URI\s0 scheme is one that \s-1URI\s0 recognizes.
.Sp
It will also be \s-1TRUE\s0 for relative URLs where a recognized
scheme was provided to the constructor, even if \f(CW\*(C`$uri\->scheme\*(C'\fR
returns \f(CW\*(C`undef\*(C'\fR for these.
.ie n .IP "$uri\->opaque" 4
.el .IP "\f(CW$uri\fR\->opaque" 4
.IX Item "$uri->opaque"
.PD 0
.ie n .IP "$uri\->opaque( $new_opaque )" 4
.el .IP "\f(CW$uri\fR\->opaque( \f(CW$new_opaque\fR )" 4
.IX Item "$uri->opaque( $new_opaque )"
.PD
Sets and returns the scheme-specific part of the \f(CW$uri\fR
(everything between the scheme and the fragment)
as an escaped string.
.ie n .IP "$uri\->path" 4
.el .IP "\f(CW$uri\fR\->path" 4
.IX Item "$uri->path"
.PD 0
.ie n .IP "$uri\->path( $new_path )" 4
.el .IP "\f(CW$uri\fR\->path( \f(CW$new_path\fR )" 4
.IX Item "$uri->path( $new_path )"
.PD
Sets and returns the same value as \f(CW$uri\fR\->opaque unless the \s-1URI\s0
supports the generic syntax for hierarchical namespaces.
In that case the generic method is overridden to set and return
the part of the \s-1URI\s0 between the \fIhost name\fR and the \fIfragment\fR.
.ie n .IP "$uri\->fragment" 4
.el .IP "\f(CW$uri\fR\->fragment" 4
.IX Item "$uri->fragment"
.PD 0
.ie n .IP "$uri\->fragment( $new_frag )" 4
.el .IP "\f(CW$uri\fR\->fragment( \f(CW$new_frag\fR )" 4
.IX Item "$uri->fragment( $new_frag )"
.PD
Returns the fragment identifier of a \s-1URI\s0 reference
as an escaped string.
.ie n .IP "$uri\->as_string" 4
.el .IP "\f(CW$uri\fR\->as_string" 4
.IX Item "$uri->as_string"
Returns a \s-1URI\s0 object to a plain \s-1ASCII\s0 string.  \s-1URI\s0 objects are
also converted to plain strings automatically by overloading.  This
means that \f(CW$uri\fR objects can be used as plain strings in most Perl
constructs.
.ie n .IP "$uri\->as_iri" 4
.el .IP "\f(CW$uri\fR\->as_iri" 4
.IX Item "$uri->as_iri"
Returns a Unicode string representing the \s-1URI.\s0  Escaped \s-1UTF\-8\s0 sequences
representing non-ASCII characters are turned into their corresponding Unicode
code point.
.ie n .IP "$uri\->canonical" 4
.el .IP "\f(CW$uri\fR\->canonical" 4
.IX Item "$uri->canonical"
Returns a normalized version of the \s-1URI.\s0  The rules
for normalization are scheme-dependent.  They usually involve
lowercasing the scheme and Internet host name components,
removing the explicit port specification if it matches the default port,
uppercasing all escape sequences, and unescaping octets that can be
better represented as plain characters.
.Sp
For efficiency reasons, if the \f(CW$uri\fR is already in normalized form,
then a reference to it is returned instead of a copy.
.ie n .IP "$uri\->eq( $other_uri )" 4
.el .IP "\f(CW$uri\fR\->eq( \f(CW$other_uri\fR )" 4
.IX Item "$uri->eq( $other_uri )"
.PD 0
.ie n .IP "URI::eq( $first_uri, $other_uri )" 4
.el .IP "URI::eq( \f(CW$first_uri\fR, \f(CW$other_uri\fR )" 4
.IX Item "URI::eq( $first_uri, $other_uri )"
.PD
Tests whether two \s-1URI\s0 references are equal.  \s-1URI\s0 references
that normalize to the same string are considered equal.  The method
can also be used as a plain function which can also test two string
arguments.
.Sp
If you need to test whether two \f(CW\*(C`URI\*(C'\fR object references denote the
same object, use the '==' operator.
.ie n .IP "$uri\->abs( $base_uri )" 4
.el .IP "\f(CW$uri\fR\->abs( \f(CW$base_uri\fR )" 4
.IX Item "$uri->abs( $base_uri )"
Returns an absolute \s-1URI\s0 reference.  If \f(CW$uri\fR is already
absolute, then a reference to it is simply returned.  If the \f(CW$uri\fR
is relative, then a new absolute \s-1URI\s0 is constructed by combining the
\&\f(CW$uri\fR and the \f(CW$base_uri\fR, and returned.
.ie n .IP "$uri\->rel( $base_uri )" 4
.el .IP "\f(CW$uri\fR\->rel( \f(CW$base_uri\fR )" 4
.IX Item "$uri->rel( $base_uri )"
Returns a relative \s-1URI\s0 reference if it is possible to
make one that denotes the same resource relative to \f(CW$base_uri\fR.
If not, then \f(CW$uri\fR is simply returned.
.ie n .IP "$uri\->secure" 4
.el .IP "\f(CW$uri\fR\->secure" 4
.IX Item "$uri->secure"
Returns a \s-1TRUE\s0 value if the \s-1URI\s0 is considered to point to a resource on
a secure channel, such as an \s-1SSL\s0 or \s-1TLS\s0 encrypted one.
.SH "GENERIC METHODS"
.IX Header "GENERIC METHODS"
The following methods are available to schemes that use the
common/generic syntax for hierarchical namespaces.  The descriptions of
schemes below indicate which these are.  Unrecognized schemes are
assumed to support the generic syntax, and therefore the following
methods:
.ie n .IP "$uri\->authority" 4
.el .IP "\f(CW$uri\fR\->authority" 4
.IX Item "$uri->authority"
.PD 0
.ie n .IP "$uri\->authority( $new_authority )" 4
.el .IP "\f(CW$uri\fR\->authority( \f(CW$new_authority\fR )" 4
.IX Item "$uri->authority( $new_authority )"
.PD
Sets and returns the escaped authority component
of the \f(CW$uri\fR.
.ie n .IP "$uri\->path" 4
.el .IP "\f(CW$uri\fR\->path" 4
.IX Item "$uri->path"
.PD 0
.ie n .IP "$uri\->path( $new_path )" 4
.el .IP "\f(CW$uri\fR\->path( \f(CW$new_path\fR )" 4
.IX Item "$uri->path( $new_path )"
.PD
Sets and returns the escaped path component of
the \f(CW$uri\fR (the part between the host name and the query or fragment).
The path can never be undefined, but it can be the empty string.
.ie n .IP "$uri\->path_query" 4
.el .IP "\f(CW$uri\fR\->path_query" 4
.IX Item "$uri->path_query"
.PD 0
.ie n .IP "$uri\->path_query( $new_path_query )" 4
.el .IP "\f(CW$uri\fR\->path_query( \f(CW$new_path_query\fR )" 4
.IX Item "$uri->path_query( $new_path_query )"
.PD
Sets and returns the escaped path and query
components as a single entity.  The path and the query are
separated by a \*(L"?\*(R" character, but the query can itself contain \*(L"?\*(R".
.ie n .IP "$uri\->path_segments" 4
.el .IP "\f(CW$uri\fR\->path_segments" 4
.IX Item "$uri->path_segments"
.PD 0
.ie n .IP "$uri\->path_segments( $segment, ... )" 4
.el .IP "\f(CW$uri\fR\->path_segments( \f(CW$segment\fR, ... )" 4
.IX Item "$uri->path_segments( $segment, ... )"
.PD
Sets and returns the path.  In a scalar context, it returns
the same value as \f(CW$uri\fR\->path.  In a list context, it returns the
unescaped path segments that make up the path.  Path segments that
have parameters are returned as an anonymous array.  The first element
is the unescaped path segment proper;  subsequent elements are escaped
parameter strings.  Such an anonymous array uses overloading so it can
be treated as a string too, but this string does not include the
parameters.
.Sp
Note that absolute paths have the empty string as their first
\&\fIpath_segment\fR, i.e. the \fIpath\fR \f(CW\*(C`/foo/bar\*(C'\fR have 3
\&\fIpath_segments\fR; "\*(L", \*(R"foo\*(L" and \*(R"bar".
.ie n .IP "$uri\->query" 4
.el .IP "\f(CW$uri\fR\->query" 4
.IX Item "$uri->query"
.PD 0
.ie n .IP "$uri\->query( $new_query )" 4
.el .IP "\f(CW$uri\fR\->query( \f(CW$new_query\fR )" 4
.IX Item "$uri->query( $new_query )"
.PD
Sets and returns the escaped query component of
the \f(CW$uri\fR.
.ie n .IP "$uri\->query_form" 4
.el .IP "\f(CW$uri\fR\->query_form" 4
.IX Item "$uri->query_form"
.PD 0
.ie n .IP "$uri\->query_form( $key1 => $val1, $key2 => $val2, ... )" 4
.el .IP "\f(CW$uri\fR\->query_form( \f(CW$key1\fR => \f(CW$val1\fR, \f(CW$key2\fR => \f(CW$val2\fR, ... )" 4
.IX Item "$uri->query_form( $key1 => $val1, $key2 => $val2, ... )"
.ie n .IP "$uri\->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )" 4
.el .IP "\f(CW$uri\fR\->query_form( \f(CW$key1\fR => \f(CW$val1\fR, \f(CW$key2\fR => \f(CW$val2\fR, ..., \f(CW$delim\fR )" 4
.IX Item "$uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )"
.ie n .IP "$uri\->query_form( \e@key_value_pairs )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e@key_value_pairs )" 4
.IX Item "$uri->query_form( @key_value_pairs )"
.ie n .IP "$uri\->query_form( \e@key_value_pairs, $delim )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e@key_value_pairs, \f(CW$delim\fR )" 4
.IX Item "$uri->query_form( @key_value_pairs, $delim )"
.ie n .IP "$uri\->query_form( \e%hash )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e%hash )" 4
.IX Item "$uri->query_form( %hash )"
.ie n .IP "$uri\->query_form( \e%hash, $delim )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e%hash, \f(CW$delim\fR )" 4
.IX Item "$uri->query_form( %hash, $delim )"
.PD
Sets and returns query components that use the
\&\fIapplication/x\-www\-form\-urlencoded\fR format.  Key/value pairs are
separated by \*(L"&\*(R", and the key is separated from the value by a \*(L"=\*(R"
character.
.Sp
The form can be set either by passing separate key/value pairs, or via
an array or hash reference.  Passing an empty array or an empty hash
removes the query component, whereas passing no arguments at all leaves
the component unchanged.  The order of keys is undefined if a hash
reference is passed.  The old value is always returned as a list of
separate key/value pairs.  Assigning this list to a hash is unwise as
the keys returned might repeat.
.Sp
The values passed when setting the form can be plain strings or
references to arrays of strings.  Passing an array of values has the
same effect as passing the key repeatedly with one value at a time.
All the following statements have the same effect:
.Sp
.Vb 5
\&    $uri\->query_form(foo => 1, foo => 2);
\&    $uri\->query_form(foo => [1, 2]);
\&    $uri\->query_form([ foo => 1, foo => 2 ]);
\&    $uri\->query_form([ foo => [1, 2] ]);
\&    $uri\->query_form({ foo => [1, 2] });
.Ve
.Sp
The \f(CW$delim\fR parameter can be passed as \*(L";\*(R" to force the key/value pairs
to be delimited by \*(L";\*(R" instead of \*(L"&\*(R" in the query string.  This
practice is often recommended for URLs embedded in \s-1HTML\s0 or \s-1XML\s0
documents as this avoids the trouble of escaping the \*(L"&\*(R" character.
You might also set the \f(CW$URI::DEFAULT_QUERY_FORM_DELIMITER\fR variable to
\&\*(L";\*(R" for the same global effect.
.Sp
The \f(CW\*(C`URI::QueryParam\*(C'\fR module can be loaded to add further methods to
manipulate the form of a \s-1URI.\s0  See URI::QueryParam for details.
.ie n .IP "$uri\->query_keywords" 4
.el .IP "\f(CW$uri\fR\->query_keywords" 4
.IX Item "$uri->query_keywords"
.PD 0
.ie n .IP "$uri\->query_keywords( $keywords, ... )" 4
.el .IP "\f(CW$uri\fR\->query_keywords( \f(CW$keywords\fR, ... )" 4
.IX Item "$uri->query_keywords( $keywords, ... )"
.ie n .IP "$uri\->query_keywords( \e@keywords )" 4
.el .IP "\f(CW$uri\fR\->query_keywords( \e@keywords )" 4
.IX Item "$uri->query_keywords( @keywords )"
.PD
Sets and returns query components that use the
keywords separated by \*(L"+\*(R" format.
.Sp
The keywords can be set either by passing separate keywords directly
or by passing a reference to an array of keywords.  Passing an empty
array removes the query component, whereas passing no arguments at
all leaves the component unchanged.  The old value is always returned
as a list of separate words.
.SH "SERVER METHODS"
.IX Header "SERVER METHODS"
For schemes where the \fIauthority\fR component denotes an Internet host,
the following methods are available in addition to the generic
methods.
.ie n .IP "$uri\->userinfo" 4
.el .IP "\f(CW$uri\fR\->userinfo" 4
.IX Item "$uri->userinfo"
.PD 0
.ie n .IP "$uri\->userinfo( $new_userinfo )" 4
.el .IP "\f(CW$uri\fR\->userinfo( \f(CW$new_userinfo\fR )" 4
.IX Item "$uri->userinfo( $new_userinfo )"
.PD
Sets and returns the escaped userinfo part of the
authority component.
.Sp
For some schemes this is a user name and a password separated by
a colon.  This practice is not recommended. Embedding passwords in
clear text (such as \s-1URI\s0) has proven to be a security risk in almost
every case where it has been used.
.ie n .IP "$uri\->host" 4
.el .IP "\f(CW$uri\fR\->host" 4
.IX Item "$uri->host"
.PD 0
.ie n .IP "$uri\->host( $new_host )" 4
.el .IP "\f(CW$uri\fR\->host( \f(CW$new_host\fR )" 4
.IX Item "$uri->host( $new_host )"
.PD
Sets and returns the unescaped hostname.
.Sp
If the \f(CW$new_host\fR string ends with a colon and a number, then this
number also sets the port.
.Sp
For IPv6 addresses the brackets around the raw address is removed in the return
value from \f(CW$uri\fR\->host.  When setting the host attribute to an IPv6 address you
can use a raw address or one enclosed in brackets.  The address needs to be
enclosed in brackets if you want to pass in a new port value as well.
.ie n .IP "$uri\->ihost" 4
.el .IP "\f(CW$uri\fR\->ihost" 4
.IX Item "$uri->ihost"
Returns the host in Unicode form.  Any \s-1IDNA\s0 A\-labels are turned into U\-labels.
.ie n .IP "$uri\->port" 4
.el .IP "\f(CW$uri\fR\->port" 4
.IX Item "$uri->port"
.PD 0
.ie n .IP "$uri\->port( $new_port )" 4
.el .IP "\f(CW$uri\fR\->port( \f(CW$new_port\fR )" 4
.IX Item "$uri->port( $new_port )"
.PD
Sets and returns the port.  The port is a simple integer
that should be greater than 0.
.Sp
If a port is not specified explicitly in the \s-1URI,\s0 then the \s-1URI\s0 scheme's default port
is returned. If you don't want the default port
substituted, then you can use the \f(CW$uri\fR\->_port method instead.
.ie n .IP "$uri\->host_port" 4
.el .IP "\f(CW$uri\fR\->host_port" 4
.IX Item "$uri->host_port"
.PD 0
.ie n .IP "$uri\->host_port( $new_host_port )" 4
.el .IP "\f(CW$uri\fR\->host_port( \f(CW$new_host_port\fR )" 4
.IX Item "$uri->host_port( $new_host_port )"
.PD
Sets and returns the host and port as a single
unit.  The returned value includes a port, even if it matches the
default port.  The host part and the port part are separated by a
colon: \*(L":\*(R".
.Sp
For IPv6 addresses the bracketing is preserved; thus
\&\s-1URI\-\s0>new(\*(L"http://[::1]/\*(R")\->host_port returns \*(L"[::1]:80\*(R".  Contrast this with
\&\f(CW$uri\fR\->host which will remove the brackets.
.ie n .IP "$uri\->default_port" 4
.el .IP "\f(CW$uri\fR\->default_port" 4
.IX Item "$uri->default_port"
Returns the default port of the \s-1URI\s0 scheme to which \f(CW$uri\fR
belongs.  For \fIhttp\fR this is the number 80, for \fIftp\fR this
is the number 21, etc.  The default port for a scheme can not be
changed.
.SH "SCHEME-SPECIFIC SUPPORT"
.IX Header "SCHEME-SPECIFIC SUPPORT"
Scheme-specific support is provided for the following \s-1URI\s0 schemes.  For \f(CW\*(C`URI\*(C'\fR
objects that do not belong to one of these, you can only use the common and
generic methods.
.IP "\fBdata\fR:" 4
.IX Item "data:"
The \fIdata\fR \s-1URI\s0 scheme is specified in \s-1RFC 2397.\s0  It allows inclusion
of small data items as \*(L"immediate\*(R" data, as if it had been included
externally.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the data scheme support the common methods
and two new methods to access their scheme-specific components:
\&\f(CW$uri\fR\->media_type and \f(CW$uri\fR\->data.  See URI::data for details.
.IP "\fBfile\fR:" 4
.IX Item "file:"
An old specification of the \fIfile\fR \s-1URI\s0 scheme is found in \s-1RFC 1738.
A\s0 new \s-1RFC 2396\s0 based specification in not available yet, but file \s-1URI\s0
references are in common use.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the file scheme support the common and
generic methods.  In addition, they provide two methods for mapping file URIs
back to local file names; \f(CW$uri\fR\->file and \f(CW$uri\fR\->dir.  See URI::file
for details.
.IP "\fBftp\fR:" 4
.IX Item "ftp:"
An old specification of the \fIftp\fR \s-1URI\s0 scheme is found in \s-1RFC 1738.\s0  A
new \s-1RFC 2396\s0 based specification in not available yet, but ftp \s-1URI\s0
references are in common use.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the ftp scheme support the common,
generic and server methods.  In addition, they provide two methods for
accessing the userinfo sub-components: \f(CW$uri\fR\->user and \f(CW$uri\fR\->password.
.IP "\fBgopher\fR:" 4
.IX Item "gopher:"
The \fIgopher\fR \s-1URI\s0 scheme is specified in
<draft\-murali\-url\-gopher\-1996\-12\-04> and will hopefully be available
as a \s-1RFC 2396\s0 based specification.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the gopher scheme support the common,
generic and server methods. In addition, they support some methods for
accessing gopher-specific path components: \f(CW$uri\fR\->gopher_type,
\&\f(CW$uri\fR\->selector, \f(CW$uri\fR\->search, \f(CW$uri\fR\->string.
.IP "\fBhttp\fR:" 4
.IX Item "http:"
The \fIhttp\fR \s-1URI\s0 scheme is specified in \s-1RFC 2616.\s0
The scheme is used to reference resources hosted by \s-1HTTP\s0 servers.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the http scheme support the common,
generic and server methods.
.IP "\fBhttps\fR:" 4
.IX Item "https:"
The \fIhttps\fR \s-1URI\s0 scheme is a Netscape invention which is commonly
implemented.  The scheme is used to reference \s-1HTTP\s0 servers through \s-1SSL\s0
connections.  Its syntax is the same as http, but the default
port is different.
.IP "\fBldap\fR:" 4
.IX Item "ldap:"
The \fIldap\fR \s-1URI\s0 scheme is specified in \s-1RFC 2255.\s0  \s-1LDAP\s0 is the
Lightweight Directory Access Protocol.  An ldap \s-1URI\s0 describes an \s-1LDAP\s0
search operation to perform to retrieve information from an \s-1LDAP\s0
directory.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the ldap scheme support the common,
generic and server methods as well as ldap-specific methods: \f(CW$uri\fR\->dn,
\&\f(CW$uri\fR\->attributes, \f(CW$uri\fR\->scope, \f(CW$uri\fR\->filter, \f(CW$uri\fR\->extensions.  See
URI::ldap for details.
.IP "\fBldapi\fR:" 4
.IX Item "ldapi:"
Like the \fIldap\fR \s-1URI\s0 scheme, but uses a \s-1UNIX\s0 domain socket.  The
server methods are not supported, and the local socket path is
available as \f(CW$uri\fR\->un_path.  The \fIldapi\fR scheme is used by the
OpenLDAP package.  There is no real specification for it, but it is
mentioned in various OpenLDAP manual pages.
.IP "\fBldaps\fR:" 4
.IX Item "ldaps:"
Like the \fIldap\fR \s-1URI\s0 scheme, but uses an \s-1SSL\s0 connection.  This
scheme is deprecated, as the preferred way is to use the \fIstart_tls\fR
mechanism.
.IP "\fBmailto\fR:" 4
.IX Item "mailto:"
The \fImailto\fR \s-1URI\s0 scheme is specified in \s-1RFC 2368.\s0  The scheme was
originally used to designate the Internet mailing address of an
individual or service.  It has (in \s-1RFC 2368\s0) been extended to allow
setting of other mail header fields and the message body.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the mailto scheme support the common
methods and the generic query methods.  In addition, they support the
following mailto-specific methods: \f(CW$uri\fR\->to, \f(CW$uri\fR\->headers.
.Sp
Note that the \*(L"foo@example.com\*(R" part of a mailto is \fInot\fR the
\&\f(CW\*(C`userinfo\*(C'\fR and \f(CW\*(C`host\*(C'\fR but instead the \f(CW\*(C`path\*(C'\fR.  This allows a
mailto \s-1URI\s0 to contain multiple comma separated email addresses.
.IP "\fBmms\fR:" 4
.IX Item "mms:"
The \fImms\fR \s-1URL\s0 specification can be found at <http://sdp.ppona.com/>.
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the mms scheme support the common,
generic, and server methods, with the exception of userinfo and
query-related sub-components.
.IP "\fBnews\fR:" 4
.IX Item "news:"
The \fInews\fR, \fInntp\fR and \fIsnews\fR \s-1URI\s0 schemes are specified in
<draft\-gilman\-news\-url\-01> and will hopefully be available as an \s-1RFC
2396\s0 based specification soon.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the news scheme support the common,
generic and server methods.  In addition, they provide some methods to
access the path: \f(CW$uri\fR\->group and \f(CW$uri\fR\->message.
.IP "\fBnntp\fR:" 4
.IX Item "nntp:"
See \fInews\fR scheme.
.IP "\fBpop\fR:" 4
.IX Item "pop:"
The \fIpop\fR \s-1URI\s0 scheme is specified in \s-1RFC 2384.\s0 The scheme is used to
reference a \s-1POP3\s0 mailbox.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the pop scheme support the common, generic
and server methods.  In addition, they provide two methods to access the
userinfo components: \f(CW$uri\fR\->user and \f(CW$uri\fR\->auth
.IP "\fBrlogin\fR:" 4
.IX Item "rlogin:"
An old specification of the \fIrlogin\fR \s-1URI\s0 scheme is found in \s-1RFC
1738.\s0 \f(CW\*(C`URI\*(C'\fR objects belonging to the rlogin scheme support the
common, generic and server methods.
.IP "\fBrtsp\fR:" 4
.IX Item "rtsp:"
The \fIrtsp\fR \s-1URL\s0 specification can be found in section 3.2 of \s-1RFC 2326.\s0
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the rtsp scheme support the common,
generic, and server methods, with the exception of userinfo and
query-related sub-components.
.IP "\fBrtspu\fR:" 4
.IX Item "rtspu:"
The \fIrtspu\fR \s-1URI\s0 scheme is used to talk to \s-1RTSP\s0 servers over \s-1UDP\s0
instead of \s-1TCP.\s0  The syntax is the same as rtsp.
.IP "\fBrsync\fR:" 4
.IX Item "rsync:"
Information about rsync is available from <http://rsync.samba.org/>.
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the rsync scheme support the common,
generic and server methods.  In addition, they provide methods to
access the userinfo sub-components: \f(CW$uri\fR\->user and \f(CW$uri\fR\->password.
.IP "\fBsip\fR:" 4
.IX Item "sip:"
The \fIsip\fR \s-1URI\s0 specification is described in sections 19.1 and 25
of \s-1RFC 3261.\s0  \f(CW\*(C`URI\*(C'\fR objects belonging to the sip scheme support the
common, generic, and server methods with the exception of path related
sub-components.  In addition, they provide two methods to get and set
\&\fIsip\fR parameters: \f(CW$uri\fR\->params_form and \f(CW$uri\fR\->params.
.IP "\fBsips\fR:" 4
.IX Item "sips:"
See \fIsip\fR scheme.  Its syntax is the same as sip, but the default
port is different.
.IP "\fBsnews\fR:" 4
.IX Item "snews:"
See \fInews\fR scheme.  Its syntax is the same as news, but the default
port is different.
.IP "\fBtelnet\fR:" 4
.IX Item "telnet:"
An old specification of the \fItelnet\fR \s-1URI\s0 scheme is found in \s-1RFC
1738.\s0 \f(CW\*(C`URI\*(C'\fR objects belonging to the telnet scheme support the
common, generic and server methods.
.IP "\fBtn3270\fR:" 4
.IX Item "tn3270:"
These URIs are used like \fItelnet\fR URIs but for connections to \s-1IBM\s0
mainframes.  \f(CW\*(C`URI\*(C'\fR objects belonging to the tn3270 scheme support the
common, generic and server methods.
.IP "\fBssh\fR:" 4
.IX Item "ssh:"
Information about ssh is available at <http://www.openssh.com/>.
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the ssh scheme support the common,
generic and server methods. In addition, they provide methods to
access the userinfo sub-components: \f(CW$uri\fR\->user and \f(CW$uri\fR\->password.
.IP "\fBsftp\fR:" 4
.IX Item "sftp:"
\&\f(CW\*(C`URI\*(C'\fR objects belonging to the sftp scheme support the common,
generic and server methods. In addition, they provide methods to
access the userinfo sub-components: \f(CW$uri\fR\->user and \f(CW$uri\fR\->password.
.IP "\fBurn\fR:" 4
.IX Item "urn:"
The syntax of Uniform Resource Names is specified in \s-1RFC 2141.\s0  \f(CW\*(C`URI\*(C'\fR
objects belonging to the urn scheme provide the common methods, and also the
methods \f(CW$uri\fR\->nid and \f(CW$uri\fR\->nss, which return the Namespace Identifier
and the Namespace-Specific String respectively.
.Sp
The Namespace Identifier basically works like the Scheme identifier of
URIs, and further divides the \s-1URN\s0 namespace.  Namespace Identifier
assignments are maintained at
<http://www.iana.org/assignments/urn\-namespaces>.
.Sp
Letter case is not significant for the Namespace Identifier.  It is
always returned in lower case by the \f(CW$uri\fR\->nid method.  The \f(CW$uri\fR\->_nid
method can be used if you want it in its original case.
.IP "\fBurn\fR:\fBisbn\fR:" 4
.IX Item "urn:isbn:"
The \f(CW\*(C`urn:isbn:\*(C'\fR namespace contains International Standard Book
Numbers (ISBNs) and is described in \s-1RFC 3187.\s0  A \f(CW\*(C`URI\*(C'\fR object belonging
to this namespace has the following extra methods (if the
Business::ISBN module is available): \f(CW$uri\fR\->isbn,
\&\f(CW$uri\fR\->isbn_publisher_code, \f(CW$uri\fR\->isbn_group_code (formerly isbn_country_code,
which is still supported by issues a deprecation warning), \f(CW$uri\fR\->isbn_as_ean.
.IP "\fBurn\fR:\fBoid\fR:" 4
.IX Item "urn:oid:"
The \f(CW\*(C`urn:oid:\*(C'\fR namespace contains Object Identifiers (OIDs) and is
described in \s-1RFC 3061.\s0  An object identifier consists of sequences of digits
separated by dots.  A \f(CW\*(C`URI\*(C'\fR object belonging to this namespace has an
additional method called \f(CW$uri\fR\->oid that can be used to get/set the oid
value.  In a list context, oid numbers are returned as separate elements.
.SH "CONFIGURATION VARIABLES"
.IX Header "CONFIGURATION VARIABLES"
The following configuration variables influence how the class and its
methods behave:
.ie n .IP "$URI::ABS_ALLOW_RELATIVE_SCHEME" 4
.el .IP "\f(CW$URI::ABS_ALLOW_RELATIVE_SCHEME\fR" 4
.IX Item "$URI::ABS_ALLOW_RELATIVE_SCHEME"
Some older parsers used to allow the scheme name to be present in the
relative \s-1URL\s0 if it was the same as the base \s-1URL\s0 scheme.  \s-1RFC 2396\s0 says
that this should be avoided, but you can enable this old behaviour by
setting the \f(CW$URI::ABS_ALLOW_RELATIVE_SCHEME\fR variable to a \s-1TRUE\s0 value.
The difference is demonstrated by the following examples:
.Sp
.Vb 2
\&  URI\->new("http:foo")\->abs("http://host/a/b")
\&      ==>  "http:foo"
\&
\&  local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
\&  URI\->new("http:foo")\->abs("http://host/a/b")
\&      ==>  "http:/host/a/foo"
.Ve
.ie n .IP "$URI::ABS_REMOTE_LEADING_DOTS" 4
.el .IP "\f(CW$URI::ABS_REMOTE_LEADING_DOTS\fR" 4
.IX Item "$URI::ABS_REMOTE_LEADING_DOTS"
You can also have the \fBabs()\fR method ignore excess \*(L"..\*(R"
segments in the relative \s-1URI\s0 by setting \f(CW$URI::ABS_REMOTE_LEADING_DOTS\fR
to a \s-1TRUE\s0 value.  The difference is demonstrated by the following
examples:
.Sp
.Vb 2
\&  URI\->new("../../../foo")\->abs("http://host/a/b")
\&      ==> "http://host/../../foo"
\&
\&  local $URI::ABS_REMOTE_LEADING_DOTS = 1;
\&  URI\->new("../../../foo")\->abs("http://host/a/b")
\&      ==> "http://host/foo"
.Ve
.ie n .IP "$URI::DEFAULT_QUERY_FORM_DELIMITER" 4
.el .IP "\f(CW$URI::DEFAULT_QUERY_FORM_DELIMITER\fR" 4
.IX Item "$URI::DEFAULT_QUERY_FORM_DELIMITER"
This value can be set to \*(L";\*(R" to have the query form \f(CW\*(C`key=value\*(C'\fR pairs
delimited by \*(L";\*(R" instead of \*(L"&\*(R" which is the default.
.SH "BUGS"
.IX Header "BUGS"
There are some things that are not quite right:
.IP "\(bu" 4
Using regexp variables like \f(CW$1\fR directly as arguments to the \s-1URI\s0 accessor methods
does not work too well with current perl implementations.  I would argue
that this is actually a bug in perl.  The workaround is to quote
them. Example:
.Sp
.Vb 2
\&   /(...)/ || die;
\&   $u\->query("$1");
.Ve
.IP "\(bu" 4
The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
\&\s-1URI\s0 constructor or when setting \s-1URI\s0 parts using the accessor methods depend on
the state of the internal \s-1UTF8\s0 flag (see utf8::is_utf8) of the string passed.
If the \s-1UTF8\s0 flag is set the \s-1UTF\-8\s0 encoded version of the character is percent
encoded.  If the \s-1UTF8\s0 flag isn't set the Latin\-1 version (byte) of the
character is percent encoded.  This basically exposes the internal encoding of
Perl strings.
.SH "PARSING URIs WITH REGEXP"
.IX Header "PARSING URIs WITH REGEXP"
As an alternative to this module, the following (official) regular
expression can be used to decode a \s-1URI:\s0
.PP
.Vb 2
\&  my($scheme, $authority, $path, $query, $fragment) =
\&  $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\e?([^#]*))?(?:#(.*))?|;
.Ve
.PP
The \f(CW\*(C`URI::Split\*(C'\fR module provides the function \fBuri_split()\fR as a
readable alternative.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
URI::file, URI::WithBase, URI::QueryParam, URI::Escape,
URI::Split, URI::Heuristic
.PP
\&\s-1RFC 2396:\s0 \*(L"Uniform Resource Identifiers (\s-1URI\s0): Generic Syntax\*(R",
Berners-Lee, Fielding, Masinter, August 1998.
.PP
<http://www.iana.org/assignments/uri\-schemes>
.PP
<http://www.iana.org/assignments/urn\-namespaces>
.PP
<http://www.w3.org/Addressing/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2009 Gisle Aas.
.PP
Copyright 1995 Martijn Koster.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS / ACKNOWLEDGMENTS"
.IX Header "AUTHORS / ACKNOWLEDGMENTS"
This module is based on the \f(CW\*(C`URI::URL\*(C'\fR module, which in turn was
(distantly) based on the \f(CW\*(C`wwwurl.pl\*(C'\fR code in the libwww-perl for
perl4 developed by Roy Fielding, as part of the Arcadia project at the
University of California, Irvine, with contributions from Brooks
Cutter.
.PP
\&\f(CW\*(C`URI::URL\*(C'\fR was developed by Gisle Aas, Tim Bunce, Roy Fielding and
Martijn Koster with input from other people on the libwww-perl mailing
list.
.PP
\&\f(CW\*(C`URI\*(C'\fR and related subclasses was developed by Gisle Aas.
