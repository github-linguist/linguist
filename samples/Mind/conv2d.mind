// MIND Language Example: 2D Convolution
// Specification reference: spec/v1.0/ir.md#linear-and-tensor-algebra (Conv2d)
//
// This example demonstrates Conv2d operations with various
// stride and padding configurations. MIND uses NHWC format.

import tensor::zeros;
import tensor::ones;

// Example 1: Basic convolution (valid padding, stride 1)
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
//
// Input format: NHWC [batch, height, width, channels_in]
// Filter format: HWCF [kernel_h, kernel_w, channels_in, channels_out]
// Output: [batch, out_h, out_w, channels_out]
//
// Expected output shape: [1, 3, 3, 2] (5-3+1 = 3 with valid padding)
fn basic_conv2d() -> Tensor<f32, [1, 3, 3, 2]> {
    // Input: 1 image, 5x5, 3 channels
    let input: Tensor<f32, [1, 5, 5, 3]> = ones([1, 5, 5, 3]);

    // Filter: 3x3 kernel, 3 input channels, 2 output channels
    let filter: Tensor<f32, [3, 3, 3, 2]> = ones([3, 3, 3, 2]);

    // Conv2d with valid padding (no padding) and stride 1
    // Output height: (5 - 3) / 1 + 1 = 3
    // Output width:  (5 - 3) / 1 + 1 = 3
    let output = conv2d(input, filter, strides=[1, 1], padding=Valid);

    output
}

// Example 2: Convolution with 'same' padding
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
// Same padding preserves spatial dimensions (with stride 1)
//
// Expected output shape: [1, 5, 5, 4]
fn same_padding_conv2d() -> Tensor<f32, [1, 5, 5, 4]> {
    // Input: 1 image, 5x5, 3 channels
    let input: Tensor<f32, [1, 5, 5, 3]> = ones([1, 5, 5, 3]);

    // Filter: 3x3 kernel, 3 input channels, 4 output channels
    let filter: Tensor<f32, [3, 3, 3, 4]> = ones([3, 3, 3, 4]);

    // Same padding: output has same spatial dims as input
    // Padding is computed automatically: pad = (kernel_size - 1) / 2
    let output = conv2d(input, filter, strides=[1, 1], padding=Same);

    output  // Shape [1, 5, 5, 4]
}

// Example 3: Strided convolution
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
// Stride reduces output spatial dimensions
//
// Expected output shape: [1, 2, 2, 8]
fn strided_conv2d() -> Tensor<f32, [1, 2, 2, 8]> {
    // Input: 1 image, 6x6, 3 channels
    let input: Tensor<f32, [1, 6, 6, 3]> = ones([1, 6, 6, 3]);

    // Filter: 3x3 kernel
    let filter: Tensor<f32, [3, 3, 3, 8]> = ones([3, 3, 3, 8]);

    // Stride 2 in both dimensions
    // Output height: (6 - 3) / 2 + 1 = 2
    // Output width:  (6 - 3) / 2 + 1 = 2
    let output = conv2d(input, filter, strides=[2, 2], padding=Valid);

    output
}

// Example 4: Custom padding
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
// Explicit padding values: [[pad_top, pad_bottom], [pad_left, pad_right]]
//
// Expected output shape: [1, 7, 9, 4]
fn custom_padding_conv2d() -> Tensor<f32, [1, 7, 9, 4]> {
    // Input: 1 image, 5x5, 3 channels
    let input: Tensor<f32, [1, 5, 5, 3]> = ones([1, 5, 5, 3]);

    // Filter: 3x3 kernel
    let filter: Tensor<f32, [3, 3, 3, 4]> = ones([3, 3, 3, 4]);

    // Custom padding: [[top=2, bottom=2], [left=3, right=3]]
    // Padded input: 5+2+2=9 height, 5+3+3=11 width
    // Output: (9-3)/1+1=7 height, (11-3)/1+1=9 width
    let output = conv2d(
        input, filter,
        strides=[1, 1],
        padding=Custom([[2, 2], [3, 3]])
    );

    output
}

// Example 5: Batched convolution
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
// Same filter applied to each image in batch
//
// Expected output shape: [batch=4, 6, 6, 16]
fn batched_conv2d() -> Tensor<f32, [4, 6, 6, 16]> {
    // Batch of 4 images
    let input: Tensor<f32, [4, 8, 8, 3]> = ones([4, 8, 8, 3]);

    // Single filter (applied to all batch elements)
    let filter: Tensor<f32, [3, 3, 3, 16]> = ones([3, 3, 3, 16]);

    // Each image in batch processed independently
    let output = conv2d(input, filter, strides=[1, 1], padding=Valid);

    output
}

// Example 6: 1x1 convolution (pointwise)
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
// 1x1 convolutions mix channels without spatial context
//
// Expected output shape: [1, 8, 8, 64]
fn pointwise_conv() -> Tensor<f32, [1, 8, 8, 64]> {
    // Input with 32 channels
    let input: Tensor<f32, [1, 8, 8, 32]> = ones([1, 8, 8, 32]);

    // 1x1 filter: channel mixing only
    let filter: Tensor<f32, [1, 1, 32, 64]> = ones([1, 1, 32, 64]);

    // No spatial reduction with 1x1 kernel
    let output = conv2d(input, filter, strides=[1, 1], padding=Valid);

    output
}

// Example 7: Depthwise convolution pattern
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
// Each input channel convolved separately (groups = channels)
//
// Note: True depthwise conv may require specialized op or grouping
fn depthwise_pattern() -> Tensor<f32, [1, 6, 6, 3]> {
    let input: Tensor<f32, [1, 8, 8, 3]> = ones([1, 8, 8, 3]);

    // Depthwise: 1 filter per input channel
    // For true depthwise, use channels_out = channels_in
    // This is approximate; real depthwise needs groups parameter
    let filter: Tensor<f32, [3, 3, 3, 3]> = ones([3, 3, 3, 3]);

    let output = conv2d(input, filter, strides=[1, 1], padding=Valid);

    output
}

// Example 8: Conv2d output shape formula
// Reference: spec/v1.0/ir.md#linear-and-tensor-algebra
// H_out = floor((H_in + 2*pad_h - kernel_h) / stride_h) + 1
fn output_shape_demo() {
    // Demonstrating shape calculation
    //
    // Input: [batch=1, H=28, W=28, C=1]
    // Filter: [H_k=5, W_k=5, C_in=1, C_out=32]
    // Stride: [2, 2]
    // Padding: Valid (pad=0)
    //
    // H_out = floor((28 + 0 - 5) / 2) + 1 = floor(23/2) + 1 = 11 + 1 = 12
    // W_out = floor((28 + 0 - 5) / 2) + 1 = 12
    //
    // Output shape: [1, 12, 12, 32]

    let input: Tensor<f32, [1, 28, 28, 1]> = zeros([1, 28, 28, 1]);
    let filter: Tensor<f32, [5, 5, 1, 32]> = zeros([5, 5, 1, 32]);

    let output = conv2d(input, filter, strides=[2, 2], padding=Valid);
    // output has shape [1, 12, 12, 32]
}
